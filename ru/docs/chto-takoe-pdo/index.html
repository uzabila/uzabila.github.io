<!doctype html>
<html lang="ru">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

	<link rel="apple-touch-icon" sizes="180x180" href="../../../assets/icons/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="../../../assets/icons/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="../../../assets/icons/favicon-16x16.png">
	<link rel="manifest" href="../../../assets/icons/site.webmanifest">
	<link rel="mask-icon" href="../../../assets/icons/safari-pinned-tab.svg" color="#787878">
	<meta name="msapplication-TileColor" content="#ffffff">
	<meta name="theme-color" content="#ffffff">

  	<!-- Bootstrap CSS -->
  	<link rel="stylesheet" href="../../../assets/css/bootstrap.min.css">
	<link rel="stylesheet" href="../../../assets/css/prism.css">
	<link rel="stylesheet" href="../../../assets/css/style.css">

    <title>Что такое PDO или расширение для работы с MySQL &#8212; Uzabila</title>
  </head>
<body class="position-relative">
 <!-- Yandex.Metrika counter --> <script type="text/javascript">     (function(m,e,t,r,i,k,a){         m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};         m[i].l=1*new Date();         for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}         k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)     })(window, document,'script','https://mc.yandex.ru/metrika/tag.js?id=103624056', 'ym');      ym(103624056, 'init', {ssr:true, clickmap:true, accurateTrackBounce:true, trackLinks:true}); </script> <noscript><div><img src="https://mc.yandex.ru/watch/103624056" style="position:absolute; left:-9999px;" alt="" /></div></noscript> <!-- /Yandex.Metrika counter -->   

<!-- navbar section -->
<section class="navbar-section">
	<nav class="navbar navbar-expand-lg navbar-light bg-white">
		<div class="container">
			<a class="navbar-brand d-flex gap-3 align-items-center" href="../../">
				<img src="../../../assets/images/sergei-150.png" alt="" width="80" height="80" class="d-inline-block align-middle">
				<div class="logo-block"><span class="fw-bold">Uzabila</span><br><span class="small-font">Сергей Ермилов</span></div>
			</a>
			<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
				<span class="navbar-toggler-icon"></span>
			</button>
			<div class="collapse navbar-collapse" id="navbarSupportedContent">
				<ul class="navbar-nav ms-0 ms-md-5 mb-2 mb-lg-0">

					<li class="nav-item">
						<a class="nav-link" title="GitHub" target="_blank" href="https://github.com/uzabila"><img src="../../../assets/images/gh.svg" alt="GitHub" width="32" height="32" class="mx-3" style="margin-top:-5px"></a>
					</li>

					<li class="nav-item">
						<a class="nav-link" href="../../about/">Обо мне</a>
					</li>

					<li class="nav-item">
						<a class="nav-link" href="../../services/">Услуги</a>
					</li>

					<li class="nav-item">
						<a class="nav-link" href="../../portfolio/">Портфолио</a>
					</li>

					<li class="nav-item">
						<a class="nav-link" href="../../docs/">Доки</a>
					</li>

					<li class="nav-item">
						<a class="nav-link" href="../../terms/">Термины</a>
					</li>
					
					<li class="nav-item">
						<a class="nav-link" href="../../book/">Книга</a>
					</li>
		
					<li class="nav-item">
						<a class="nav-link" href="../../contacts/">Контакты</a>
					</li>
				</ul>
				<div class="ms-auto">
                    <a href="../../../" class="link-dark link-offset-2 link-underline-opacity-25 link-underline-opacity-100-hover">English</a>
                </div>

			</div>
		</div>
	</nav>
</section>
<!-- ---------- --> 
<!-- END HEADER -->
<!-- ---------- -->

<div class="container">
	<div class="row mb-3 mb-md-4 mb-lg-5">
		<div class="col-12 single-content-column">
			<p><a href="../" class="link-secondary">Доки</a></p>
			<h1 class="fw-600">Что такое PDO или расширение для работы с MySQL</h1>

<p>Рассмотрим расширение для PHP под названием PDO, что это такое и как нам работать с этим расширением. Вкратце, PDO (PHP Data Objects) – это некая прослойка в виде универсального способа работы с базами данных.</p>

<h2>Настройка параметров PDO</h2>

<div class="attention-blue"><a href="https://www.php.net/manual/en/book.pdo.php" target="_blank" rel="noreferrer noopener">Официальная документация PDO (PHP Data Object)</a></div>

<p>Перед подключением к серверу баз данных MySQL необходимо иметь:</p>

<ol>
<li>Сервер базы данных MySQL, базу данных и учетную запись, имеющую доступ к базе данных.</li>
<li>Драйвер PDO MySQL, включенный в файле php.ini сервера.</li>
</ol>

<p>Предположим, что у вас есть локальный сервер базы данных MySQL, который содержит следующую информацию:</p>

<ul>
<li>Хостом является <code>localhost</code>.</li>
<li>База данных на локальном сервере баз данных называется <code>bookdb</code>.</li>
<li>Учетную запись с пользователем <code>root</code> и паролем <code>'S@cr@t1!'</code>, которая может получить доступ к базе данных bookdb.</li>
</ul>

<p>В большинстве случаев в качестве локального сервера многие программисты используют OpenServer (сайт — <em>ospanel.io/download</em>). Я также использую этот сервер на своем ноутбуке на Windows 10. Очень классный сервер и если вы будете его использовать — не поленитесь задонатить автору проекта.</p>

<p>В PHP мы можем создать файл <strong><em>config.php</em></strong> и разместить в нем параметры базы данных:</p>

<pre><code class="language-php">&lt;?php

$host = 'localhost';
$db = 'bookdb';
$user = 'root';
$password = 'S@cr@t1!';</code></pre>

<p>Чтобы использовать параметры базы данных, мы можем включить файл <strong><em>config.php</em></strong> с помощью конструкции <code>require</code> в любой php-файл на сервере:</p>

<pre><code class="language-php">&lt;?php

require 'config.php';</code></pre>

<h2>Включение драйвера PDO_MySQL</h2>

<p>PDO_MYSQL — это драйвер, реализующий интерфейс PDO. PDO использует драйвер PDO_MYSQL для подключения к базе данных MySQL.</p>

<p>Чтобы проверить, включен ли драйвер PDO_MYSQL, откройте файл <strong><em>php.ini</em></strong>. Файл <strong><em>php.ini</em></strong> часто находится в каталоге php. Например, вы можете найти файл <strong><em>php.ini</em></strong> в каталоге <strong>C:\xampp\php</strong>, если вы используете XAMPP под Windows.</p>

<p>Кроме того, различные версии PHP вы можете скачать с официального сайта на <a href="https://www.php.net/downloads.php" target="_blank" rel="noreferrer noopener">этой странице</a>.</p>

<p>Ниже показана строка расширения в файле php.ini:</p>

<pre><code class="language-php">;extension=php_pdo_mysql.dll</code></pre>

<p>Чтобы включить расширение, вам нужно раскомментировать его, удалив точку с запятой (;) из начала строки следующим образом:</p>

<pre><code class="language-php">extension=php_pdo_mysql.dll</code></pre>

<p>После этого необходимо перезапустить веб-сервер, чтобы изменения вступили в силу.</p>

<h2>Имя источника данных MySQL или DSN</h2>

<p>PDO использует имя источника данных (DSN), которое содержит следующую информацию:</p>

<ul>
<li>хост сервера базы данных</li>
<li>имя базы данных</li>
<li>имя пользователя</li>
<li>пароль для доступа к БД</li>
<li>другие параметры, такие как наборы символов и т. д.</li>
</ul>

<p>PDO использует эту информацию для установления соединения с сервером базы данных. Для подключения к серверу базы данных MySQL используется следующий формат имени источника данных:</p>

<pre><code class="language-php">"mysql:host=host_name;dbname=db_name;charset=UTF8"</code></pre>

<p>Например:</p>

<pre><code class="language-php">$dsn = "mysql:host=localhost;dbname=bookdb;charset=UTF8";</code></pre>

<div class="attention-blue"><strong>Обратите внимание</strong>, что charset UTF-8 устанавливает набор символов соединения с базой данных в UTF-8.</div>

<h2>Создание БД</h2>

<p>Сначала войдите на сервер баз данных MySQL под пользователем <code>root</code> из командной строки в Windows или терминала в macOS и Linux:</p>

<pre><code class="language-bash">mysql -u root</code></pre>

<p>И вам будет предложено ввести пароль; введите пароль для пользователя <b>root</b>, и вы подключены к серверу MySQL.</p>

<p>Далее создайте базу данных <code>bookdb</code>, выполнив следующий запрос <code>CREATE DATABASE</code>:</p>

<pre><code class="language-sql">CREATE DATABASE IF NOT EXISTS bookdb;</code></pre>

<p>Затем выберем нужную нам базу данных <code>bookdb</code>:</p>

<pre><code class="language-sql">USE bookdb;</code></pre>

<p>После этого выполните следующий запрос <code>CREATE TABLE</code> для создания таблицы <code>publishers</code>:</p>

<pre><code class="language-sql">CREATE TABLE IF NOT EXISTS publishers (
    publisher_id INT AUTO_INCREMENT,
    name VARCHAR(255) NOT NULL,
    PRIMARY KEY (publisher_id)
);</code></pre>

<p>Наконец, выполните следующий запрос <code>CREATE TABLE</code> для создания таблицы <code>books</code>:</p>

<pre><code class="language-sql">CREATE TABLE IF NOT EXISTS books (
    book_id INT AUTO_INCREMENT,
    title VARCHAR(255) NOT NULL,
    isbn VARCHAR(13) NULL,
    published_date DATE NULL,
    publisher_id INT NULL,
    PRIMARY KEY (book_id),
    CONSTRAINT fk_publisher FOREIGN KEY (publisher_id)
        REFERENCES publishers (publisher_id)
);</code></pre>

<h2>Подключение к БД</h2>

<p>Другой метод, использующий PHP-скрипт для подключения к MySQL — это использование PDO. Этот метод похоже на предыдущий, но с небольшими изменениями:</p>

<p>1. В <strong>public_html</strong> создайте файл с именем <strong>pdoconfig.php</strong> и вставьте следующий код. Как всегда, не забудьте заменить значения переменных на информацию из вашей базы данных. Сохраните и закройте файл, как только закончите.</p>

<pre><code class="language-php">&lt;?php
    $host = 'localhost';
    $dbname = 'databasename';
    $username = 'username';
    $password = 'password';</code></pre>

<p>2. Создайте другой файл под названием <strong>databaseaseconnect.php</strong> в том же каталоге, но с кодом ниже. Если вы назвали предыдущий файл по-другому, убедитесь, что изменили значение <code>required_once</code>.</p>

<pre><code class="language-php">&lt;?php
require_once 'pdoconfig.php';
 
try {
    $conn = new PDO("mysql:host=$host;dbname=$dbname", $username, $password);
    echo "Connected to $dbname at $host successfully.";
} catch (PDOException $pe) {
    die("Could not connect to the database $dbname :" . $pe-&gt;getMessage());
}</code></pre>

<p>Подключение к базе данных PDO требует создания нового объекта PDO с именем источника данных (<strong>DSN</strong> — Data Source Name), именем пользователя (<strong>username</strong>) и паролем (<strong>password</strong>).</p>

<p>DSN определяет тип базы данных, имя базы данных и при необходимости любую другую информацию, связанную с базой данных. Это переменные и значения, которые мы указали в файле <strong>dbconfig.php</strong>, на которые однажды была сделана ссылка строкой <code>require_once</code> в <strong>databaseaseconnect.php</strong>.</p>

<p>В последнем вы найдете код <code>try</code> … <code>catch</code> …  Это означает, что сценарий попытается подключиться к MySQL, используя предоставленный код, но в случае возникновения проблемы будет выполнен код в разделе <code>catch</code>. Вы можете использовать блок <code>catch</code> для отображения сообщений об ошибках подключения или запустить альтернативный код, если блок try не работает.</p>

<p>Если соединение установлено успешно, он выведет сообщение «Подключено к <strong>$dbname</strong> на <strong>$host</strong> успешно». Однако, если попытка не удалась, код перехвата покажет простое сообщение об ошибке и завершит сценарий.</p>

<p>Следующий сценарий <strong><em>index.php</em></strong> иллюстрирует, как подключиться к базе данных <code>bookdb</code> на сервере баз данных MySQL с учетной записью <code>root</code>:</p>

<pre><code class="language-php">&lt;?php

require 'config.php'; // подключение файла с данными от БД

$dsn = "mysql:host=$host;dbname=$db;charset=UTF8";

try {
	$pdo = new PDO($dsn, $user, $password);

	if ($pdo) {
		echo "Соединение с базой $db успешно!";
	}
} catch (PDOException $e) {
	echo $e-&gt;getMessage();
}</code></pre>

<p>Как это работает.</p>

<p>Сначала создаем новый объект PDO с именем источника данных, пользователем и паролем. Объект PDO является экземпляром класса PDO.</p>

<p>Далее, выводим сообщение об успешном соединении с БД, если соединение установлено успешно, или сообщение об ошибке, если произошла ошибка соединения.</p>

<p>Если у вас все настроено правильно, вы увидите следующее сообщение:</p>

<pre><code class="language-bash">Соединение с базой bookdb успешно!</code></pre>

<p>Итак! Давайте еще раз кратко.</p>

<p>Сначала создаем файл <em><strong>config.php</strong></em> для хранения параметров базы данных:</p>

<pre><code class="language-php">&lt;?php

$host     = 'localhost';
$db       = 'bookdb';
$user     = 'root';
$password = '';</code></pre>

<p>Далее, создаем новый файл <strong><em>connect.php</em></strong>, который подключается к базе данных <code>bookdb</code>:</p>

<pre><code class="language-php">&lt;?php

require 'config.php';

$dsn = "mysql:host=$host;dbname=$db;charset=UTF8";

try {
	$options = [PDO::ATTR_ERRMODE =&gt; PDO::ERRMODE_EXCEPTION];

	$conn = new PDO($dsn, $user, $password, $options);

	if ($conn) {
		echo "Connected to the $db database successfully!";
	}
} catch (PDOException $e) {
	echo $e-&gt;getMessage();
}</code></pre>

<p>Чтобы сделать этот процесс более удобным для повторного использования, вы можете определить функцию с именем <code>connect()</code>, которая возвращает новое соединение с базой данных и возвращает его из файла <strong><em>connect.php</em></strong>:</p>

<pre><code class="language-php">&lt;?php

require_once 'config.php';

function connect($host, $db, $user, $password)
{
	$dsn = "mysql:host=$host;dbname=$db;charset=UTF8";

	try {
		$options = [PDO::ATTR_ERRMODE =&gt; PDO::ERRMODE_EXCEPTION];

		return new PDO($dsn, $user, $password, $options);
	} catch (PDOException $e) {
		die($e-&gt;getMessage());
	}
}

return connect($host, $db, $user, $password);</code></pre>

<p>Чтобы подключиться к базе данных в других файлах, вы используете конструкцию <code>require</code> следующим образом:</p>

<pre><code class="language-php">&lt;?php

$pdo = require 'connect.php';

var_dump($pdo);</code></pre>

<p>Конструкция <code>require</code> загружает файл <strong><em>connect.php</em></strong> и возвращает новый экземпляр <code>PDO</code>, возвращенный функцией <code>connect()</code>.</p>

<h2>Подход ООП для PDO</h2>

<p>Рассмотрим использование подхода на основе классов Объектно-Ориентированного Программирования (ООП).</p>

<p>Чтобы использовать класс вместо функции для создания нового соединения с базой данных, нужно выполнить несколько шагов.</p>

<p>Во-первых, создайте новый файл с именем <strong><em>Connection.php</em></strong> и определите класс <code>Connection</code>:</p>

<pre><code class="language-php">&lt;?php

require_once 'config.php';

class Connection
{
	public static function make($host, $db, $user, $password)
	{
		$dsn = "mysql:host=$host;dbname=$db;charset=UTF8";

		try {
			$options = [PDO::ATTR_ERRMODE =&gt; PDO::ERRMODE_EXCEPTION];

			return new PDO($dsn, $username, $password, $options);
		} catch (PDOException $e) {
			die($e-&gt;getMessage());
		}
	}
}

return Connection::make($host, $db, $user, $password);</code></pre>

<p>Класс <code>Connection</code> имеет метод <code>make()</code>, который возвращает новый экземпляр PDO.</p>

<p>Во-вторых, используйте файл <strong><em>Connection.php</em></strong> в других файлах сценариев следующим образом:</p>

<pre><code class="language-php">&lt;?php

$pdo = require 'Connection.php';
var_dump($pdo);</code></pre>

<p>Мы создали базу данных <code>bookdb</code> на сервере MySQL и разработали повторно используемый скрипт для подключения к базе данных.</p>

<h2>Подготовленные запросы PDO</h2>

<p>Рассмотрим теперь подготовленные запросы PDO и то, как эффективно их использовать.</p>

<p>Подготовленный запрос — это шаблон для выполнения одного или нескольких SQL-запросов с различными значениями. Подготовленный оператор является высокоэффективным и помогает защитить приложение от SQL-инъекций.</p>

<p>Когда сервер базы данных выполняет запрос, он проходит два основных этапа: <strong>подготовка</strong> и <strong>выполнение</strong>.</p>

<p><strong>Подготовка</strong> — сервер базы данных проверяет синтаксис SQL-запроса и инициализирует внутренние ресурсы сервера для этапа выполнения.</p>

<p><strong>Выполнение</strong> — приложение связывает значения и отправляет SQL-запрос на сервер базы данных. Сервер базы данных выполняет запрос с привязанными значениями, используя внутренние ресурсы сервера, выделенные на этапе подготовки.</p>

<h3>Создание подготовленного запроса в PDO</h3>

<p>Чтобы создать подготовленный запрос в PDO, выполните действия, которые я опишу ниже.</p>

<p>1. <strong>Во-первых</strong>, создаем шаблонный SQL-запрос. Например:</p>

<pre><code class="language-sql">$sql = 'INSERT INTO authors (first_name, last_name)
        VALUES (?, ?)';</code></pre>

<p>В этом выражении <code>INSERT</code> есть два вопросительных знака (?). Они называются <span class="back-yellow">позиционными заполнителями</span>.</p>

<p>При выполнении оператора необходимо передать значения в <span class="back-yellow">позиционные заполнители</span> по их позициям. Другими словами, например, в первый заполнитель нужно передать имя, а во второй — фамилию.</p>

<p>2. <strong>Во-вторых</strong>, вызовите метод <code>prepare()</code> экземпляра PDO:</p>

<pre><code class="language-php">$statement = $pdo-&gt;prepare($sql);</code></pre>

<p>Метод <code>prepare()</code> возвращает новый экземпляр класса PDOStatement.</p>

<p>3. <strong>В-третьих</strong>, вызовите метод <code>execute()</code> и передайте значения заполнителям:</p>

<pre><code class="language-php">$statement-&gt;execute(['Sandra', 'Aamodt']);</code></pre>

<p>Метод <code>execute()</code> заменит первый заполнитель на ‘Sandra’, а второй — на ‘Aamodt’ в операторе вставки.</p>

<p>Соединим все вместе.</p>

<p>Ниже показано, как использовать подготовленный запрос для вставки новой строки в таблицу «авторов»:</p>

<pre><code class="language-php">&lt;?php

$pdo = require 'connect.php';

$sql = 'insert into authors(first_name, last_name)
        values(?,?)';

$statement = $pdo-&gt;prepare($sql);

$statement-&gt;execute(['Sandra', 'Aamodt']);</code></pre>

<p>Выше в коде мы использовали вставку файла с данными для соединения с Базой Данных.</p>

<h3>Использование именованных заполнителей</h3>

<p>Когда вы используете <span class="back-yellow">позиционные заполнители</span> в операторе SQL, вам необходимо передать значения, соответствующие позициям заполнителей.</p>

<p>Если в SQL-операторе много заполнителей, очень легко использовать неправильные позиции. Чтобы избежать этого, можно использовать <span class="back-yellow">именованные заполнители</span>. Например:</p>

<pre><code class="language-sql">$sql = 'INSERT INTO authors (first_name, last_name)
        VALUES (:first_name,:last_name)';</code></pre>

<p>В этом примере вместо вопросительных знаков (?) используется имя параметра, перед которым ставится двоеточие (:). Двоеточие требуется в операторе SQL.</p>

<p>При выполнении оператора необходимо передать ассоциативный массив в метод execute() следующим образом:</p>

<pre><code class="language-php">$statement-&gt;execute([
	'first_name' =&gt; 'Henry',
	'last_name' =&gt; 'Aaron'
]);</code></pre>

<p>Обратите внимание, что важен ключ массива, а не порядок элементов. Также, можно использовать символ : в ключах массива по желанию:</p>

<pre><code class="language-php">$statement-&gt;execute([
	':first_name' =&gt; 'Henry',
	':last_name' =&gt; 'Aaron'
]);</code></pre>

<p>Порядок элементов массива не важен, поэтому вы можете использовать массив с элементами в любом порядке. Например:</p>

<pre><code class="language-php">$statement-&gt;execute([
	'last_name' =&gt; 'Aaron',
	'first_name' =&gt; 'Henry',
]);</code></pre>

<p>Соединим все вместе.</p>

<pre><code class="language-php">&lt;?php

$pdo = require 'connect.php';

$sql = 'INSERT INTO authors (first_name, last_name)
        VALUES (:first_name,:last_name)';

$statement = $pdo-&gt;prepare($sql);

$statement-&gt;execute([
	'last_name' =&gt; 'Aaron',
	'first_name' =&gt; 'Henry',
]);</code></pre>

<h3>Связанные значения</h3>

<p>В приведенных выше примерах мы передаем значения в метод <code>execute()</code> для выполнения запроса. Эти утверждения называются не связанными запросами.</p>

<p>Помимо несвязанных запросов, PDO также поддерживает связанные запросы. Связанные запросы позволяют явно связать значение или переменную с именованным или позиционным заполнителем.</p>

<p>Чтобы связать значение, используется метод <code>bindValue()</code> объекта <code>PDOStatement</code>:</p>

<pre><code class="language-php">public PDOStatement::bindValue ( mixed $parameter , mixed $value , int $data_type = PDO::PARAM_STR ) : bool</code></pre>

<p>Метод <code>bindValue()</code> имеет три параметра:</p>

<ul>
<li><code>$parameter</code> задает имя параметра <code>:parameter</code>, если в запросе используются именованные заполнители, или индекс параметра, если в запросе используются позиционные заполнители. В случае использования позиционных заполнителей первый параметр начинается с индекса 1.</li>
<li><code>$value</code> указывает значение, которое нужно привязать к запросу.</li>
<li><code>$data_type</code> указывает тип данных для параметра, используя <code>PDO::PARAM_*</code>, например, <code>PDO::PARAM_INT</code>. По умолчанию <code>$data_type</code> — это <code>PDO::PARAM_STR</code>.</li>
</ul>

<p>В следующем примере показано, как вставить автора <code>Nick Abadzis</code> в таблицу <code>authors</code> с помощью связанного запроса:</p>

<pre><code class="language-php">&lt;?php

$pdo = require 'connect.php';

$sql = 'INSERT INTO authors (first_name, last_name)
        VALUES (?, ?)';

$statement = $pdo-&gt;prepare($sql);

$statement-&gt;bindValue(':first_name', 'Nick');
$statement-&gt;bindValue(':last_name', 'Abadzis');

$statement-&gt;execute();</code></pre>

<p>Когда вы используете метод <code>bindValue()</code>, метод <code>execute()</code> выполняет запрос со значениями, переданными методу <code>bindValue()</code>, а не со значениями на момент выполнения метода <code>execute()</code>. Например:</p>

<pre><code class="language-php">&lt;?php

$pdo = require 'connect.php';

$sql = 'INSERT INTO authors (first_name, last_name)
        VALUES (:first_name,:last_name)';

$statement = $pdo-&gt;prepare($sql);

$author = [
	'first_name' =&gt; 'Chris',
	'last_name' =&gt; 'Abani',
];

$statement-&gt;bindValue(':first_name', $author['first_name']);
$statement-&gt;bindValue(':last_name', $author['last_name']);

// изменение автора
$author['first_name'] = 'Tom';
$author['last_name'] = 'Abate';

// выполнение запроса со значением Chris Abani
$statement-&gt;execute();</code></pre>

<p>В данном примере:</p>

<ol>
<li>Во-первых, привязываем значения ‘Chris’ и ‘Abate’ к параметрам имени и фамилии.</li>
<li>Во-вторых, изменяем значения переменной <code>$author.</code></li>
<li>В-третьих, выполняем запрос. Однако метод <code>execute()</code> использует значения, переданные методу <code>bindValue()</code>, а не значение <code>$author</code> на момент выполнения метода <code>execute()</code>.</li>
</ol>

<p>Поэтому в дело вступает метод <code>bindParam()</code>.</p>

<h3>Метод bindParam()</h3>

<p>Для выполнения запроса, значения параметров которого оцениваются во время выполнения метода execute(), используется метод <code>bindParam()</code>:</p>

<pre><code class="language-php">public PDOStatement::bindParam ( mixed $parameter , mixed &amp;$variable , int $data_type = PDO::PARAM_STR , int $length = ? , mixed $driver_options = ? ) : bool</code></pre>

<p>Следующий пример иллюстрирует использование метода <code>bindParam()</code> для вставки нового автора в таблицу <code>authors</code>:</p>

<pre><code class="language-php">&lt;?php

$pdo = require 'connect.php';

$sql = 'insert into authors(first_name, last_name)
        values(:first_name,:last_name)';

$statement = $pdo-&gt;prepare($sql);

$author = [
	'first_name' =&gt; 'Chris',
	'last_name' =&gt; 'Abani',
];

$statement-&gt;bindParam(':first_name', $author['first_name']);
$statement-&gt;bindParam(':last_name', $author['last_name']);

// изменение переменной автора
$author['first_name'] = 'Tom';
$author['last_name'] = 'Abate';

// выполняем запрос со значением Tom Abate
$statement-&gt;execute();</code></pre>

<p>В этом примере метод <code>execute()</code> оценивает переменную <code>$author</code> во время выполнения, поэтому вместо нее используются значения ‘Tom’ и ‘Abage’.</p>

<p>Используйте подготовленный запрос PHP для многократного выполнения запроса с разными значениями.</p>

<p>Используйте позиционные заполнители (?) или именованные заполнители (<code>:parameter</code>) в SQL-запросе, прежде чем передать его в метод <code>prepare()</code> объекта <code>PDOStatement</code>.</p>

<p>Используйте метод <code>execute()</code> со значениями для запуска несвязанного запроса.</p>

<p>Используйте метод <code>bindValue()</code> или <code>bindParam()</code> для привязки значений к связанному запросу.</p>

<h2>Вставка данных</h2>

<p>Как и в предыдущем примере, нам сначала нужно соединение с базой данных, которое выполняется путем создания нового объекта PDO — смотрите выше пример того, как это сделать, если вы не уверены. </p>

<p>Поскольку соединение с базой данных MySQL является объектом PDO, вы должны использовать различные методы PDO (любую функцию, которая является частью любого объекта) для подготовки и выполнения запросов. Методы объектов вызываются так:</p>

<pre><code class="language-php">$the_Object-&gt;the_Method();</code></pre>

<p>PDO позволяет подготовить SQL-код перед его выполнением. SQL-запрос обрабатывается и исправляется перед выполнением. </p>

<p>Упрощенная атака SQL-инъекцией может быть выполнена просто путем ввода SQL-кода в поле на форме. Например:</p>

<pre><code class="language-php">// хакер пишет это в поле имени пользователя формы входа
john"; DROP DATABASE user_table;

// финальный запрос становится таким
"SELECT * FROM user_table WHERE username = john"; DROP DATABASE user_table;</code></pre>

<p>Так как существует синтаксически корректный SQL-код, точка с запятой делает <code>DROP DATABASE user_table</code> новым SQL-запросом, а ваша пользовательская таблица удаляется.</p>

<p>Подготовленные операторы не позволяют символам <strong>«</strong> и <strong>;</strong> завершить исходный запрос, и вредоносная инструкция <code>DROP DATABASE</code> никогда не будет выполнена.</p>

<div class="attention-red"><strong>Важно</strong>! Вы всегда должны использовать подготовленные операторы при отправке или получении данных из базы данных с PDO.</div>

<p>Чтобы использовать подготовленные операторы, вы должны написать новую переменную, которая вызывает метод <code>prepare()</code> объекта базы данных.</p>

<p>Переходим к правильному коду:</p>

<pre><code class="language-php">&lt;?php
$servername = "mysql.hostinger.com";
$database = "u266072517_name"; 
$username = "u266072517_user";
$password = "buystuffpwd";
$sql = "mysql:host=$servername;dbname=$database;";
$dsn_Options = [PDO::ATTR_ERRMODE =&gt; PDO::ERRMODE_EXCEPTION];

// создание нового соединения с базой данных MySQL с помощью PDO, $my_Db_Connection - это объект
try { 
  $my_Db_Connection = new PDO($sql, $username, $password, $dsn_Options);
  echo "Connected successfully";
} catch (PDOException $error) {
  echo 'Connection error: ' . $error-&gt;getMessage();
}

// устанавливаем переменные для человека, которого мы хотим добавить в базу данных
$first_Name = "Test";
$last_Name = "Testing";
$email = "Testing@testing.com";

// здесь мы создаем переменную, которая вызывает метод prepare() объекта базы данных.
// SQL-запрос, который вы хотите выполнить, вводится как параметр, а заполнители записываются следующим образом: placeholder_name
$my_Insert_Statement = $my_Db_Connection-&gt;prepare("INSERT INTO Students (name, lastname, email) VALUES (:first_name, :last_name, :email)");

// теперь мы сообщаем скрипту, на какую переменную фактически ссылается каждый заполнитель, используя метод bindParam()
// первый параметр - это место в выражении выше - второй параметр - это переменная, к которой он должен относиться
$my_Insert_Statement-&gt;bindParam(:first_name, $first_Name);
$my_Insert_Statement-&gt;bindParam(:last_name, $last_Name);
$my_Insert_Statement-&gt;bindParam(:email, $email);

// выполните запрос, используя данные, которые мы только что определили
// метод execute() возвращает TRUE, если он успешен, и FALSE, если нет, позволяя писать свои собственные сообщения здесь
if ($my_Insert_Statement-&gt;execute()) {
  echo "New record created successfully";
} else {
  echo "Unable to create record";
}

// на этом этапе вы можете изменить данные переменных и повторить процедуру для добавления новых данных в базу данных
$first_Name = "John";
$last_Name = "Smith";
$email = "john.smith@email.com";
$my_Insert_Statement-&gt;execute();

// выполняем снова, когда переменные изменились
if ($my_Insert_Statement-&gt;execute()) {
  echo "New record created successfully";
} else {
  echo "Unable to create record";
}</code></pre>

<p>В строках 28, 29 и 30 мы используем метод <code>bindParam()</code> объекта базы данных. Также существует совершенно другой метод <code>bindValue()</code>.</p>

<p><strong>bindParam()</strong> — Этот метод оценивает данные при достижении метода <code>execute()</code>. В первый раз, когда скрипт достигает метода <code>execute()</code>, он видит, что <code>$first_Name</code> соответствует <code>"Test"</code>, связывает это значение и выполняет запрос. </p>

<p>Когда сценарий достигает второго метода <code>execute()</code>, он видит, что <code>$first_Name</code> теперь соответствует <code>"John"</code>, связывает это значение и снова запускает запрос с новыми значениями. Важно помнить, что мы определили запрос один раз и повторно использовали его с разными данными в разных точках скрипта.</p>

<p><strong>bindValue()</strong> — Этот метод оценивает данные, как только достигается <code>bindValue()</code>. Поскольку значение <code>$first_Name</code> было установлено на <code>"Test"</code> при достижении <code>bindValue()</code>, оно будет использоваться каждый раз, когда вызывается метод <code>execute()</code> для <code>$my_Insert_Statement</code>.</p>

<p>Обратите внимание, что мы повторно используем переменную <code>$first_Name</code> и второй раз даем ей новое значение. Если вы проверите свою базу данных после выполнения этого скрипта, у вас есть оба определенных имени, несмотря на то, что в конце скрипта переменная <code>$first_Name</code> равна <code>"John"</code>. Помните, что PHP оценивает весь скрипт перед его фактическим выполнением.</p>

<p>Если вы обновите скрипт, чтобы заменить <strong>bindParam</strong> на <strong>bindValue</strong>, вы дважды вставите в MySQL <code>"Test Testing"</code> в БД и <code>"John Smith"</code> будет проигнорирован.</p>

<h2>SELECT в PDO без параметров</h2>

<p>Существует несколько способов выполнения SELECT-запроса с помощью PDO, которые различаются в основном наличием параметров, типом параметров и типом результата. Я покажу примеры для каждого случая, чтобы вы могли выбрать тот, который подходит вам больше всего.</p>

<p>Просто убедитесь, что у вас правильно настроена переменная соединения PDO, которая должна выполнять SQL-запросы с помощью PDO и сообщать вам о возможных ошибках.</p>

<p>Если в запросе не будут использоваться переменные, мы можем использовать обычный метод query() вместо prepare и execute.</p>

<pre><code class="language-php">// получение всех пользователей
$stmt = $pdo-&gt;query("SELECT * FROM users");</code></pre>

<p>Это даст нам объект <code>$stmt</code>, который может быть использован для получения актуальных строк.</p>

<h3>Получение одной строки</h3>

<p>Если запрос должен вернуть только одну строку, то можно просто вызвать метод <code>fetch()</code> переменной <code>$stmt</code>:</p>

<pre><code class="language-php">// получение последнего зарегистрированного пользователя
$stmt = $pdo-&gt;query("SELECT * FROM users ORDER BY id DESC LIMIT 1");
$user = $stmt-&gt;fetch();</code></pre>

<p>Обратите внимание, что в PHP вы можете «цепочкой» вызывать методы, вызывая метод уже возвращенного объекта, например:</p>

<pre><code class="language-php">$user = $pdo-&gt;query("SELECT * FROM users ORDER BY id DESC LIMIT 1")-&gt;fetch();</code></pre>

<h3>Выбор нескольких строк</h3>

<p>Существует два способа получения нескольких строк, возвращенных в результате запроса. Самый традиционный способ — использовать метод <code>fetch()</code> в цикле <code>while</code>:</p>

<pre><code class="language-php">$stmt = $pdo-&gt;query("SELECT * FROM users");
while ($row = $stmt-&gt;fetch()) {
    echo $row['name']."&lt;br /&gt;\n";
}</code></pre>

<p>Этот метод может быть рекомендован, если строки должны обрабатываться по одной. Например, если такая обработка является единственным действием, которое необходимо выполнить, или если данные должны быть как-то предварительно обработаны перед использованием.</p>

<p>Но наиболее предпочтительным способом получения нескольких строк, которые должны быть показаны на странице, является вызов замечательного вспомогательного метода <code>fetchAll()</code>. Он поместит все строки, возвращенные после запроса, в массив PHP, который позже можно будет использовать для вывода данных с помощью шаблона (что считается эффективнее, чем вывод данных прямо во время процесса <strong>fetch</strong>). Таким образом, код будет выглядеть следующим образом:</p>

<pre><code class="language-php">$data = $pdo-&gt;query("SELECT * FROM users")-&gt;fetchAll();
// где-то позднее:
foreach ($data as $row) {
    echo $row['name']."&lt;br /&gt;\n";
}</code></pre>

<h2>SELECT в PDO с параметрами</h2>

<p>Но чаще всего нам приходится использовать переменную или две в запросе, и в таком случае мы должны использовать подготовленный запрос (также называемый запросом с параметрами), сначала подготавливая запрос с параметрами (или плейсхолдерами), а затем выполняя его, передавая переменные отдельно.</p>

<p>В PDO мы можем использовать как позиционные, так и именованные плейсхолдеры. Для простых запросов лично я предпочитаю позиционные заполнители, мне они кажутся менее громоздкими, но это дело вкуса.</p>

<h3>Запрос SELECT с позиционными заполнителями</h3>

<pre><code class="language-php">// выбрать конкретного пользователя по id
$stmt = $pdo-&gt;prepare("SELECT * FROM users WHERE id=?");
$stmt-&gt;execute([$id]); 
$user = $stmt-&gt;fetch();</code></pre>

<h3>Запрос SELECT с именованными заполнителями</h3>

<pre><code class="language-php">// выбрать конкретного пользователя по id
$stmt = $pdo-&gt;prepare("SELECT * FROM users WHERE id=:id");
$stmt-&gt;execute(['id' =&gt; $id]); 
$user = $stmt-&gt;fetch();</code></pre>

<h3>Выбор нескольких строк</h3>

<p>Получение нескольких строк с помощью подготовленного запроса будет идентично показанному выше запросу:</p>

<pre><code class="language-php">$stmt = $pdo-&gt;prepare("SELECT * FROM users LIMIT ?, ?");
$stmt-&gt;execute([$limit, $offset]); 
while ($row = $stmt-&gt;fetch()) {
    echo $row['name']."&lt;br /&gt;\n";
}</code></pre>

<p>Или:</p>

<pre><code class="language-php">$stmt = $pdo-&gt;prepare("SELECT * FROM users LIMIT :limit, :offset");
$stmt-&gt;execute(['limit' =&gt; $limit, 'offset' =&gt; $offset]); 
$data = $stmt-&gt;fetchAll();
// где-то позднее:
foreach ($data as $row) {
    echo $row['name']."&lt;br /&gt;\n";
}</code></pre>

<h2>Обработка ошибок</h2>

<p>PDO поддерживает три различные стратегии обработки ошибок:</p>

<ul>
<li><code>PDO::ERROR_SILENT</code> — PDO устанавливает код ошибки для проверки с помощью методов <code>PDO::errorCode()</code> и <code>PDO::errorInfo()</code>. <code>PDO::ERROR_SILENT</code> — это режим по умолчанию.</li>
<li><code>PDO::ERRMODE_WARNING</code> — помимо установки кода ошибки, PDO выдает сообщение <code>E_WARNING</code>.</li>
<li><code>PDO::ERRMODE_EXCEPTION</code> — Помимо установки кода ошибки, PDO вызовет исключение <code>PDOException</code>.</li>
</ul>

<p>Чтобы задать стратегию обработки ошибок, вы можете передать ассоциативный массив в конструктор PDO следующим образом:</p>

<pre><code class="language-php">$pdo = new PDO($dsn, $user, $password, [PDO::ATTR_ERRMODE =&gt; PDO::ERRMODE_EXCEPTION]);</code></pre>

<p>Или вы можете использовать метод <code>setAttribute()</code> экземпляра PDO:</p>

<pre><code class="language-php">$pdo-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);</code></pre>

<h2>Решение проблем</h2>

<p>Существует несколько распространенных проблем при подключении к базе данных MySQL.</p>

<p>Если драйвер MySQL не включен в файл <strong><em>php.ini</em></strong>, вы получите сообщение об ошибке:</p>

<pre><code class="language-php">could not find driver</code></pre>

<p>Если вы указали неправильный пароль, вы получите следующее сообщение об ошибке:</p>

<pre><code class="language-shell">SQLSTATE[HY000] [1045] Access denied for user 'root'@'localhost' (using password: YES)</code></pre>

<p>Если вы указали неверное имя базы данных или база данных не существует, вы получите следующее сообщение об ошибке:</p>

<pre><code class="language-shell">SQLSTATE[HY000] [1049] Unknown database 'bookdb'</code></pre>

<p>Если вы укажете неверное имя хоста базы данных, появится следующее сообщение об ошибке:</p>

<pre><code class="language-shell">SQLSTATE[HY000] [2002] php_network_getaddresses: getaddrinfo failed: No such host is known.</code></pre>

<p>Если запрос, который мы выполнили и вставили в базу данных MySQL, был успешным, мы увидим следующее сообщение вроде:</p>

<pre><code class="language-shell">Connect Successfully
New record created successfully</code></pre>

<p>Однако бывают случаи, когда вставка новой записи будет с ошибкой при SQL вставке. Но не стоит беспокоиться, есть несколько способов исправить эти ошибки MySQL.</p>

<p>В строке 7 PDO-соединения настраивается режим «Ошибка» для отображения всех исключений (<strong>display all exceptions</strong>). Если бы это было отключено в скрипте и запрос бы не удался, то вы бы не получили никаких сообщений об ошибках. При включенном режиме исключений отображается конкретная проблема.</p>

<div class="attention-red"><strong>Важно</strong>! Это следует использовать только при разработке скрипта, так как он может раскрыть имена баз данных и таблиц, которые вы, возможно, предпочтете скрывать от любого, кто может пытаться получить злонамеренный доступ к вашим данным.</div>

<p>В приведенном выше случае, когда вместо круглых скобок были использованы фигурные скобки, ошибка выглядит аналогично:</p>

<pre><code class="language-shell">Fatal error: Uncaught exception 'PDOException' with message 'SQLSTATE[42000]: Syntax error or access violation: 1064 You have an error in your SQL syntax; 
check the manual that corresponds to your MySQL server version for the right syntax to use near '{name, lastname, email} VALUES ('Thom', 'Vial', 'thom.v@some.com')' at line 1"</code></pre>

<p>Другие возможные проблемы, с которыми вы можете столкнуться:</p>

<ul>
<li>Указаны неверные колонки (несуществующие колонки или орфографическая ошибка).</li>
<li>Один тип значения присваивается другому типу столбца. Например, если мы попытаемся присвоить число 47 в столбце Name, мы получим ошибку, потому что это должно быть строковое значение. Но если бы мы назначили число в кавычках, например, «47», это сработало бы, потому что наше число будет назначено столбцу в виде строки.</li>
<li>Попытка ввести данные в таблицу, которой не существует, или орфографическая ошибка таблицы.</li>
</ul>

<p>Все эти ошибки можно легко исправить, следуя рекомендациям по сообщениям об ошибках или проверяя журнал ошибок.</p>

<p>После успешного ввода данных мы должны увидеть, что они добавлены в нашу базу данных. Вот пример таблицы, в которую мы добавили наши данные при просмотре из <strong><em>phpMyAdmin</em></strong>.</p>

<figure>
	<img src="images/php-mysql-09.jpg" alt="" class="img-fluid">
</figure>

<p>Теперь вы знаете как использовать PHP для вставки данных в базу данных MySQL с помощью MySQLi и PDO.</p>

<p>Вы также узнали, как устранять распространенные ошибки подключения. Знание того, как использовать PHP для добавления данных в базу данных MySQL, полезно независимо от того, учитесь ли вы программировать или создаете свой веб-сайт.</p>


		</div>
	</div>
</div>
<div class="container">
	<div class="row">
		<div class="col-12 col-md-7">
			<div class="mb-3 mb-mb-4 d-flex gap-3">
				<div>
					<img alt="Сергей Ермилов" src="../../../assets/images/sergei-450.png" height="68" width="68">
				</span>
				</div>
				<div>
					<a href="../../about/" class="link-dark link-offset-2 link-underline-opacity-25 link-underline-opacity-100-hover">Сергей Ермилов</a><br>
					<span>Дизайнер, верстальщик, фронтенд-разработчик, PHP и WordPress энтузиаст, главный редактор сайта</span>
				</div>
			</div> 
		</div>
		<div class="col-12 col-md-5">
			<span class="text-muted">Опубликовано 5 февраля 2023 в 12:00</span><br>Теги: MySQL, PDO, PHP
		</div>
	</div>
</div>

<!-- ------------ -->
<!-- START FOOTER -->
<!-- ------------ -->
<footer class="py-5">
	<div class="container">
		<div class="row">
			<div class="col-12 col-md-4 my-auto">
				<span class="fw-500 text-muted">Uzabila</span>
			</div>
			<div class="col-12 col-md-4 text-center my-auto">
				<img src="../../../assets/images/sergei-150.png" alt="Sergei Ermilov" width="80" height="80">
			</div>
			<div class="col-12 col-md-4 my-auto text-end">
				<span class="fw-500 text-muted">&copy; 2008-<script>document.write(new Date().getFullYear())</script></span>
			</div>
		</div>
	</div>
</footer>

	<script src="../../../assets/js/bootstrap.bundle.min.js"></script>
	<script src="../../../assets/js/app.js"></script>
	<script src="../../../assets/js/prism.js"></script>	

  </body>
</html>