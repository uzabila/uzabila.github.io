<!doctype html>
<html lang="ru">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

	<link rel="apple-touch-icon" sizes="180x180" href="../../../assets/icons/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="../../../assets/icons/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="../../../assets/icons/favicon-16x16.png">
	<link rel="manifest" href="../../../assets/icons/site.webmanifest">
	<link rel="mask-icon" href="../../../assets/icons/safari-pinned-tab.svg" color="#787878">
	<meta name="msapplication-TileColor" content="#ffffff">
	<meta name="theme-color" content="#ffffff">

  	<!-- Bootstrap CSS -->
  	<link rel="stylesheet" href="../../../assets/css/bootstrap.min.css">
	<link rel="stylesheet" href="../../../assets/css/prism.css">
	<link rel="stylesheet" href="../../../assets/css/style.css">

    <title>GitHub для начинающих &#8212; Uzabila</title>
  </head>
<body class="position-relative">
 <!-- Yandex.Metrika counter --> <script type="text/javascript">     (function(m,e,t,r,i,k,a){         m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};         m[i].l=1*new Date();         for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}         k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)     })(window, document,'script','https://mc.yandex.ru/metrika/tag.js?id=103624056', 'ym');      ym(103624056, 'init', {ssr:true, clickmap:true, accurateTrackBounce:true, trackLinks:true}); </script> <noscript><div><img src="https://mc.yandex.ru/watch/103624056" style="position:absolute; left:-9999px;" alt="" /></div></noscript> <!-- /Yandex.Metrika counter -->   

<!-- navbar section -->
<section class="navbar-section">
	<nav class="navbar navbar-expand-lg navbar-light bg-white">
		<div class="container">
			<a class="navbar-brand d-flex gap-3 align-items-center" href="../../">
				<img src="../../../assets/images/sergei-150.png" alt="" width="80" height="80" class="d-inline-block align-middle">
				<div class="logo-block"><span class="fw-bold">Uzabila</span><br><span class="small-font">Сергей Ермилов</span></div>
			</a>
			<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
				<span class="navbar-toggler-icon"></span>
			</button>
			<div class="collapse navbar-collapse" id="navbarSupportedContent">
				<ul class="navbar-nav ms-0 ms-md-5 mb-2 mb-lg-0">

					<li class="nav-item">
						<a class="nav-link" title="GitHub" target="_blank" href="https://github.com/uzabila"><img src="../../../assets/images/gh.svg" alt="GitHub" width="32" height="32" class="mx-3" style="margin-top:-5px"></a>
					</li>

					<li class="nav-item">
						<a class="nav-link" href="../../about/">Обо мне</a>
					</li>

					<li class="nav-item">
						<a class="nav-link" href="../../services/">Услуги</a>
					</li>

					<li class="nav-item">
						<a class="nav-link" href="../../portfolio/">Портфолио</a>
					</li>

					<li class="nav-item">
						<a class="nav-link" href="../../docs/">Доки</a>
					</li>

					<li class="nav-item">
						<a class="nav-link" href="../../terms/">Термины</a>
					</li>
					
					<li class="nav-item">
						<a class="nav-link" href="../../book/">Книга</a>
					</li>
		
					<li class="nav-item">
						<a class="nav-link" href="../../contacts/">Контакты</a>
					</li>
				</ul>
				<div class="ms-auto">
                    <a href="../../../" class="link-dark link-offset-2 link-underline-opacity-25 link-underline-opacity-100-hover">English</a>
                </div>

			</div>
		</div>
	</nav>
</section>
<!-- ---------- --> 
<!-- END HEADER -->
<!-- ---------- -->

<div class="container-fluid">
	<div class="row mb-3 mb-md-4 mb-lg-5">

		<div class="col-12 col-lg-3">
			<div class="content-blocks bg-light p-3">
				<div>
					<b>Содержание</b>
				</div>
				<div>    
					<span class="text-muted">1</span> <a href="#Slovar_GitHub"><span>Словарь GitHub</span></a>
				</div>
				<div>
					<span class="text-muted">2</span> <a href="#Komandy_GitHub"><span>Команды GitHub</span></a>
				</div>
				<div>
					<span class="text-muted">3</span> <a href="#Ustanovka_Git_i_rabota_v_konsoli"><span>Установка Git и работа в консоли</span></a>
				</div>
				<div>
					<span class="text-muted">4</span> <a href="#Sozdanie_repozitoria_GitHub"><span>Создание репозитория GitHub</span></a>
				</div>
				<div>
					<span class="text-muted">5</span> <a href="#Otkatyvaem_izmenenia"><span>Откатываем изменения</span></a>
				</div>
				<div>
					<span class="text-muted">6</span> <a href="#Sozdanie_vetok_i_vetvlenia_v_GitHub"><span>Создание веток и ветвления в GitHub</span></a>
				</div>
				<div>
					<span class="text-muted">7</span> <a href="#Konflikty_i_osibki"><span>Конфликты и ошибки</span></a>
				</div>
				<div>
					<span class="text-muted">8</span> <a href="#Otpravlaem_kod_na_GitHub_i_nastraivaem_SSH-kluci"><span>Отправляем код на GitHub и настраиваем SSH-ключи</span></a>
				</div>
				<div>
					<span class="text-muted">9</span> <a href="#Proverka_SSH-soedinenia_s_GitHub"><span>Проверка SSH-соединения с GitHub</span></a>

					<div class="px-3 pt-2">
						<div>
							<span class="text-muted">9.1</span> <a href="#Proverka_susestvuusih_klucej_SSH"><span>Проверка существующих ключей SSH</span></a>
						</div>
						<div>
							<span class="text-muted">9.2</span> <a href="#Sozdanie_novogo_kluca_SSH_i_dobavlenie_ego_v_ssh-agent"><span>Создание нового ключа SSH и добавление его в ssh-agent</span></a>
						</div>
						<div>
							<span class="text-muted">9.3</span> <a href="#Dobavlenie_vasego_SSH-kluca_v_ssh-agent_na_GitHub"><span>Добавление вашего SSH-ключа в ssh-agent на GitHub</span></a>
						</div>
						<div>
							<span class="text-muted">9.4</span> <a href="#Dobavlenie_kluca_SSH_v_svou_ucetnuu_zapis_GitHub"><span>Добавление ключа SSH в свою учетную запись GitHub</span></a>
						</div>
						<div>
							<span class="text-muted">9.5</span> <a href="#Proverka_soedinenia"><span>Проверка соединения</span></a>
						</div>
					</div>
				</div>
				<div>
					<span class="text-muted">10</span> <a href="#Otpravka_pervogo_lokalnogo_proekta_na_GitHub"><span>Отправка первого локального проекта на GitHub</span></a>

					<div class="px-3 pt-2">
						<div>
							<span class="text-muted">10.1</span> <a href="#Ubedites_cto_git_otslezivaet_vas_proekt"><span>Убедитесь, что git отслеживает ваш проект</span></a>
						</div>
						<div>
							<span class="text-muted">10.2</span> <a href="#Sozdajte_udalennyj_repozitorij_na_Github"><span>Создайте удаленный репозиторий на Github</span></a>
						</div>
						<div>
							<span class="text-muted">10.3</span> <a href="#Podklucite_lokalnuu_papku_proekta_k_vasemu_pustomu_hranilisu_na_Github"><span>Подключите локальную папку проекта к вашему пустому хранилищу на Github</span></a>
						</div>
						<div>
							<span class="text-muted">10.4</span> <a href="#Cto_lucse_sdelat_pered_otpravkoj_lokalnyh_fajlov"><span>Что лучше сделать перед отправкой локальных файлов</span></a>
						</div>
					</div>
				</div>
				<div>
					<span class="text-muted">11</span> <a href="#Rabota_s_dvuh_komputerov"><span>Работа с двух компьютеров</span></a>
				</div>
				<div>
					<span class="text-muted">12</span> <a href="#Kod_v_cuzoj_repozitorij_GitHub_ili_pomogaem_drugu"><span>Код в чужой репозиторий GitHub или помогаем другу</span></a>
				</div>
			</div>
		</div>
		<div class="col-12 col-lg-9	single-content-column">
			<p><a href="../" class="link-secondary">Доки</a></p>
			<h1 class="fw-600">GitHub для начинающих</h1>

<p>В большинстве компаний и на любых курсах по разработке необходимо работать в системе контроля версий Git. Часто, программист отправляет свои задания на проверку и получает обновления в этой системе.</p>

<p>Ниже материал о том как пользоваться GitHub, который вам поможет начать работать с этой системой. Руководство подготовлена на основе курса школы «HTML Academy», опыта использования GitHub и различных статей по разработке.</p>

<p>Данный курс можно найти и на других сайта, т.к. курс не новый и его растащили по всему интернету, но любые обновления курса и дополнения я делаю только здесь.</p>

<h2><span id="Slovar_GitHub">Словарь GitHub</span></h2>

<p>Для понимания некоторых слов из терминологии разработчиков и их использования — используйте этот небольшой словарик:</p>

<ul>
<li><strong>git</strong> (рус. — гит) — система контроля версий</li>
<li><strong>github</strong> (рус. — гитхаб) — сервис репозиториев и совместной разработки</li>
<li><strong>репозиторий</strong> — хранилище (каталог) файлов проекта</li>
<li><strong>локальный репозиторий</strong> — репозиторий, расположенный на локальном компьютере программиста</li>
<li><strong>удалённый репозиторий</strong> — репозиторий, находящийся на удалённом сервере</li>
<li><strong>fork</strong> (рус. — форк) — копия репозитория или внешняя ветка текущего репозитория</li>
<li><strong>обновление из апстрима</strong> — обновление локальной версии форка до последней версии основного репозитория, от которого сделан форк</li>
<li><strong>обновление из ориджина</strong> — обновление локальной версии репозитория до последней удалённой версии этого репозитория</li>
<li><strong>клонирование</strong> (англ. — <strong>clone</strong>) — скачивание репозитория с удалённого сервера на локальный компьютер в определённый каталог для дальнейшей работы с этим каталогом как с репозиторием</li>
<li><strong>ветка</strong> (англ. — <strong>branch</strong>) — параллельная версия репозитория, которая является частью репозитория, но не влияет на основную версию, что позволяет свободно работать в параллельной версии, а после внесения правок объединить их с главной версией</li>
<li><strong>мастер</strong> (англ. — <strong>master</strong>) — основная ветка репозитория</li>
<li><strong>коммит</strong> (англ. — <strong>commit</strong>) — фиксация изменений или запись изменений в репозиторий на локальной машине</li>
<li><strong>пул</strong> (англ. — <strong>pull</strong>) — получение последних изменений с удалённого репозитория</li>
<li><strong>пуш</strong> (англ. — <strong>push</strong>) — отправка коммитов в удалённый репозитория</li>
<li><strong>пулреквест</strong> (англ. — <strong>pull request</strong>) — запрос на слияние форка репозитория с основным репозиторием и при этом пулреквест может быть принят или отклонён владельцем репозитория</li>
<li><strong>мёрдж</strong> (англ. — <strong>merge</strong>) — слияние изменений из какой-либо ветки репозитория с любой веткой этого же репозитория</li>
<li><strong>кодревью</strong> (англ. — <strong>codereview</strong>) — процесс проверки кода на соответствие определённым требованиям, задачам и внешнему виду.</li>
</ul>

<h2><span id="Komandy_GitHub">Команды GitHub</span></h2>

<p>Собрал в одном месте git команды на каждый день, мини справочник, который всегда под рукой.</p>

<p>Инициализация нового git-репозитория:</p>

<pre><code class="language-bash">$ git init</code></pre>

<p>Отобразить статус git-репозитория и рабочего каталога:</p>

<pre><code class="language-bash">$ git status</code></pre>

<p>Добавить в индекс все измененные файлы:</p>

<pre><code class="language-bash">$ git add .</code></pre>

<p>Добавить в индекс изменения:</p>

<pre><code class="language-bash">$ git add &lt;filename&gt;</code></pre>

<p>Удалить файл с внесением в индекс:</p>

<pre><code class="language-bash">$ git rm &lt;filename&gt;</code></pre>

<p>Переименование файла/перенос в другую директорию с внесением в индекс:</p>

<pre><code class="language-bash">$ git mv &lt;filename&gt;</code></pre>

<p>Зафиксировать изменения в репозитории, находящиеся в индексе:</p>

<pre><code class="language-bash">$ git commit -m "&lt;message&gt;"</code></pre>

<p>Комбо:</p>

<pre><code class="language-bash">$ git commit -a -m "&lt;message&gt;" = git add . + git commit -m "&lt;message&gt;"</code></pre>

<p>История коммитов:</p>

<pre><code class="language-bash">$ git log</code></pre>

<p>Переход к старому состоянию проекта:</p>

<pre><code class="language-bash">$ git checkout &lt;hash&gt;</code></pre>

<p>Переход к старому состоянию проекта и удалению последующих фиксаций (параметр&nbsp;<code>--hard</code>&nbsp;указывает, что рабочий каталог должен быть обновлен в соответствии с новым <strong>head</strong> ветки):</p>

<pre><code class="language-bash">$ git reset --hard &lt;hash&gt;</code></pre>

<p>Клонирование проекта из удаленного репозитория</p>

<pre><code class="language-bash">$ git clone &lt;откуда&gt; &lt;куда&gt;</code></pre>

<p>Примеры <strong>git clone</strong>:</p>

<pre><code class="language-bash">$ git clone ssh://dmn@192.168.1.100:22/var/www/superproject/htdocs/.git superproject
$ git clone /home/username/project myrepo
$ git clone http://user@somehost:port/~user/repository/project.git
$ git clone --bare hello hello.git</code></pre>

<p>Последний пример создает т.н. «чистый» репозиторий. «Чистые» репозитории не хранят рабочие каталоги и обычно используются для расшаривания.</p>

<p>Обычный git-репозиторий подразумевает, что вы будете использовать его как рабочую директорию, поэтому вместе с файлами проекта в актуальной версии, git хранит все служебные, «чисто»-репозиториевские файлы в поддиректории .git. </p>

<p>В удаленных репозиториях нет смысла хранить рабочие файлы на диске (как это делается в рабочих копиях), а все что им действительно нужно — это дельты изменений и другие бинарные данные репозитория. Вот это и есть «чистый» репозиторий.</p>

<p>Получение изменений из удаленного репозитория и их слияние с локальным:</p>

<pre><code class="language-bash">$ git pull</code></pre>

<p>Внесение локальных изменений на удаленный:</p>

<pre><code class="language-bash">$ git push</code></pre>

<p>Просмотр веток:</p>

<pre><code class="language-bash">$ git branch</code></pre>

<p>Добавление ветки:</p>

<pre><code class="language-bash">$ git branch &lt;имя_ветки&gt;</code></pre>

<p>Удаление ветки:</p>

<pre><code class="language-bash">$ git branch &lt;имя_ветки&gt; -d</code></pre>

<p>Переход между ветками:</p>

<pre><code class="language-bash">$ git checkout &lt;имя_ветки&gt;</code></pre>

<p>Слияние двух веток:</p>

<pre><code class="language-bash">$ git merge &lt;имя_ветки&gt;</code></pre>

<p>Дополнительные материалы:</p>

<p><a href="https://githowto.com/ru" target="_blank" rel="noreferrer noopener nofollow">Интерактивный учебник по git</a></p>

<p><a href="http://git-scm.com/book/ru/v2" target="_blank" rel="noreferrer noopener nofollow">Большая книга по git</a></p>

<h2><span id="Ustanovka_Git_i_rabota_v_konsoli">Установка Git и работа в консоли</span></h2>

<p>Рассмотрим как установить Git на Windows и Mac, а также познакомимся с консолью для работы с Гитом.</p>

<p>Для работы я буду использовать терминал Cmder. Для установки и начала работы с ним нам нужно скачать его с официального сайта — <em><strong>cmder.net</strong></em>.</p>

<p>Есть два варианта для скачивания — <strong>Mini</strong> и <strong>Full</strong>. Нам нужна версия Full, т.к. только она содержит Git.</p>

<p>Скачанный архив нам нужно просто распаковать. Устанавливать программу не нужно.</p>

<p>Запускаем файл <strong>cmder.exe</strong>.</p>

<p>Данный терминал может запускать несколько оболочек:</p>

<ul>
<li><strong>cmd</strong> — стандартная консоль Windows</li>
<li><strong>powershell</strong> — продвинутая оболочка Microsoft</li>
<li><strong>bash</strong> — оболочка, которая запускается по умолчанию на серверах Linux</li>
</ul>

<p>Мы будем использовать <strong>bash</strong>.</p>

<div>
<figure><img src="images/git-bash.jpg" alt="" class="img-fluid"></figure>
</div>

<p>Для того, чтобы при запуске открывался именно bash — нам нужно настроить cmder.</p>

<p>Открываем <strong>Настройки</strong> (Setings).</p>

<div>
<figure><img src="images/git-bash-1.jpg" alt="" class="img-fluid"></figure>
</div>

<p>Далее переходим в <strong>Startup</strong>. Далее видим настройку <strong>Specified named task</strong> и выбираем <strong>{bash::bash}</strong>.</p>

<div>
<figure><img src="images/git-bash-2.jpg" alt="" class="img-fluid"></figure>
</div>

<p>Далее перезапускаем терминал <strong>cmder</strong>. На вкладке внизу окна видим надпись <em><strong>bash.exe</strong></em> — это то, что нам нужно.</p>

<div>
<figure><img src="images/git-bash-3.jpg" alt="" class="img-fluid"></figure>
</div>

<p>Если у вас вместо текстов в консоли непонятные символы, как на скриншоте выше, то это говорит о том, что терминал не знает о русской версии Windows.</p>

<p>Чтобы исправить данную ситуацию мы должны в Настройках прописать две строчки.</p>

<p>Переходим в <strong><em>Настройки</em></strong> (Settings), во вкладку <strong><em>StartUp</em></strong> — <strong><em>Environments</em></strong>.</p>

<div>
<figure><img src="images/git-bash-ru.jpg" alt="" class="img-fluid"></figure></div>

<p>И добавляем две строчки:</p>

<pre><code class="language-bash">set LC_ALL=ru_RU.UTF-8
set LANG=ru_RU.UTF-8</code></pre>

<p>Перезапускаем Cmder и видим, что никаких символов нет и у нас корректное отображение русского языка.</p>

<p>Как правило после запуска Cmder мы видим строчку, где указаны <em>имя_ пользователя</em> и после собачки (@) <em>имя_компьютера</em>. После может быть указано имя названия пакета программ и после чего идет значок — <strong>тильда</strong> (~). </p>

<p>Тильда означает домашнюю папку, что-то вроде: <em>C:\пользователи(users)\имя_пользователя</em>.</p>
<p>На следующей строке мы видим знак доллара (стрелку или что-то подобное) и мигающий курсор. Всё это называется командной строкой. Аналогия чата с компьютером.</p>

<p>Чтобы понять где мы находимся мы будем постоянно пользоваться командой <strong><em>pwd</em></strong>.</p>

<pre><code class="language-bash">pwd</code></pre>

<div>
<figure><img src="images/git-bash-pwd.jpg" alt="" class="img-fluid"></figure></div>

<p>Работа в терминале подразумевает нахождение в какой-либо папке. После запуска вы попадаете в домашнюю директорию.</p>

<p>Настройки Cmder позволяют поменять домашний каталог.</p>

<p>Смена папки производится командой <strong><em>cd</em></strong>.</p>

<pre><code class="language-bash">cd Downloads</code></pre>

<div>
<figure><img src="images/git-bash-cd.jpg" alt="" class="img-fluid"></figure></div>

<p>Чтобы вернуться в папку в которой мы только что были мы вводим: <strong><em>cd —</em></strong>.</p>

<pre><code class="language-bash">cd -</code></pre>

<p>Чтобы вернуться в домашнюю папку мы можем использовать команду:</p>

<pre><code class="language-bash">cd ~</code></pre>

<p>Чтобы переходить по папкам нет необходимости писать команды с переходом в каждую вложенную папку, можно писать, например, так:</p>

<pre><code class="language-bash">cd Downloads/cmder</code></pre>

<p>Чтобы вернуться в папку на уровень выше, мы должны написать:</p>

<pre><code class="language-bash">cd ..</code></pre>

<p>Если мы были в папке <em><strong>Downloads/cmder</strong></em>, то после этой команды мы окажемся в папке <em><strong>Downloads</strong></em>.</p>

<p>Команду можно использовать и таким образом:</p>

<pre><code class="language-bash">cd ../../</code></pre>

<p>Тогда мы попадем в папку <em>c:\users\</em>.</p>

<p>Чтобы посмотреть содержимое папки в которой мы находимся, мы используем команду <strong>ls</strong> (от английского — list):</p>

<pre><code class="language-bash">ls</code></pre>

<p>Если мы хотим посмотреть список файлов не в той папке в которой мы сейчас, то используем команду, например (для рабочего стола):</p>

<pre><code class="language-bash">ls ~/Desktop</code></pre>

<p>Чтобы было удобнее смотреть список файлов мы можем добавить флаг «-1» и тогда список файлов выведется в столбик:</p>

<pre><code class="language-bash">ls -1</code></pre>

<p>Если вы хотите открыть в проводнике Windows папку в которой вы сейчас находитесь, то используйте команду:</p>

<pre><code class="language-bash">start .</code></pre>

<p>Эта команда позволяет открывать не только папки, но и файлы. Если вы введете команду <strong><em>start</em></strong> с названием файла, например, <strong><em>index.js</em></strong>, то файл откроется в IDE, которая у вас задана по умолчанию для данного типа файлов.</p>

<div class="attention-blue"><strong>Справка</strong>. Очень удобно в терминале cmder использовать клавишу <strong>TAB</strong> для быстрого набора имен директорий и файлов в этих директориях.</div>

<p>К примеру, если вы хотите перейти в папку Downloads, то после того, как вы набрали <strong><em>cd ~/D</em></strong> вы можете нажать <strong>TAB</strong> и терминал подскажет или вставит слово Download автоматически.</p>

<p>Таким образом нет необходимости писать постоянно названия папок и файлов.</p>

<p>Давайте посмотрим как установить Git на Mac, если вы не используете компьютер с Windows.</p>

<p>На Mac-ах уже установлен терминал и нам просто нужно установить Git. Для этого переходим на сайт: <em>git-scm.com</em>. И далее находим справа ниже кнопку: <em>Download for Mac</em>.</p>

<div>
<figure><img src="images/git-bash-mac.jpg" alt="" class="img-fluid"></figure></div>

<p>После скачивания файлов запускаем установщик. Компьютер может показать предупреждение, что «<em>Программа не может быть открыта, т.к. её автор является неустановленным разработчиком</em>«.</p>

<p>Идем в <em><strong>Настройки</strong></em> и далее в <em><strong>Системные настройки</strong></em>. Выбираем <strong><em>Защита и безопасность</em></strong> и видим внизу кнопку <strong><em>Подтвердить вход</em></strong>. Жмем её.</p>

<div>
<figure><img src="images/git-bash-4.jpg" alt="" class="img-fluid"></figure></div>

<p>Теперь установщик откроется и мы проходим все шаги установки Git.</p>

<p>Далее запускаем терминал в котором мы будем работать с Git.</p>
<div>
<figure><img src="images/git-bash-5.jpg" alt="" class="img-fluid"></figure></div>

<p>Все команды терминала на Mac работают также как и в терминале для Windows.</p>

<h2><span id="Sozdanie_repozitoria_GitHub">Создание репозитория GitHub</span></h2>

<p>Рассмотрим как фиксировать и отслеживать изменения в проекте через систему контроля версий Git.</p>

<p>Для начала создаем папку проекта. Потом переходим в неё и проверяем какие файлы она содержит.</p>

<pre><code class="language-bash">cd ~/Desktop/Projects/Keksholidays/
ls -1</code></pre>

<p>Выглядит это примерно так:</p>

<div>
<figure><img src="images/git-bash-6.jpg" alt="" class="img-fluid"></figure></div>
<p>На этом этапе мы можем начать использовать Git.</p>

<p>Сперва мы должны указать для Git имя и e-mail автора. Git записывает их в каждом изменении.</p>

<p>Все команды системы контроля начинаются со слова <strong><em>git</em></strong>. Используем следующую команду:</p>

<pre><code class="language-bash">git config --global user.name "&lt;your_name&gt;"</code></pre>

<p>Флаг <code>--global</code> сообщает <strong>git</strong>, что настройка будет применена для всех проектов, <code>user.name</code> — имя настройки.</p>

<p>В кавычках мы меняем <code>&lt;your_name&gt;</code> на имя автора. </p>

<p>Повторяем операцию для почты автора:</p>

<pre><code class="language-bash">git config --global user.email "you@email"</code></pre>

<p>И также в кавычках указываем почтовый адрес автора. Это нужно настроить один раз.</p>

<p>Теперь мы можем проверить все настройки, и что они сохранились, следующей командой:</p>

<pre><code class="language-bash">git config --list</code></pre>

<p>В терминале вы увидите примерно следующие строки:</p>

<pre><code class="language-bash">user.name=michael
user.email=michael@gmail.com</code></pre>

<p>Все настройки сохранены в файле <strong><em>.gitconfig</em></strong> и его содержимое мы можем посмотреть командой:</p>

<pre><code class="language-bash">cat ~/.gitconfig</code></pre>

<p>Данный файл можно отредактировать в редакторе и даже скопировать на другой компьютер, например, если вы хотите, чтобы на работе у вас были такие же настройки как дома.</p>

<p>Теперь git настроен и можно сделать из нашего проекта репозиторий и начать отслеживать изменения.</p>

<p>Для этого мы инициализируем git командой:</p>

<pre><code class="language-bash">git init</code></pre>

<p>Мы увидим в ответ сообщение о том, что пустой репозиторий инициализирован:</p>

<div>
<figure><img src="images/git-bash-7.jpg" alt="" class="img-fluid"></figure></div>

<p>Чтобы убедиться в том, что инициализация прошла успешно мы используем команду, которая покажет все файлы в каталоге, включая скрытые файлы:</p>

<pre><code class="language-bash">ls -1 -a
// также можно писать команду короче ls -1a</code></pre>

<p>Флаг <strong>-1</strong> показывает файлы в столбик, а флаг <strong>-a</strong> показывает скрытые файлы.</p>

<p>Появилась папка <strong>.git</strong>. Она делает из простого проекта репозиторий. Её удалять нельзя, особенно, если вы еще не разбираетесь хорошо в том, что для чего нужно и как это работает. В этой папке хранится вся история изменений.</p>

<p>Дальше мы переходим к тем методам, которые будем использовать в каждом проекте. Изначально нам нужно понять какое у нас состояние репозитория. Делаем это командой:</p>

<pre><code class="language-bash">git status</code></pre>

<p>И мы увидим следующее:</p>

<div>
<figure><img src="images/git-rep-1.jpg" alt="" class="img-fluid"></figure></div>

<p>Эта команда показывает состояние репозитория и мы видим, что у нас выводится фраза «<em>On branch master</em>«. Git сообщает нам, что мы находимся в ветке <strong>master</strong>. Про ветки и ветвления мы будем говорить в следующих разделах курса, а пока будем работать в этой главной ветке.</p>

<p>Также вы можете увидеть фразу «<em>initial commit</em>«, которая означает, что мы в самом начале и еще пока ничего не зафиксировали.</p>

<p>Далее мы видим «<em>Untracked files</em>«, где приводится список файлов, которые мы пока не отслеживаем. Изменения этих файлов пока не сохранены и не зафиксированы.</p>

<p>Мы видим, что файлы на данном этапе выделаны красным цветом и не отслеживаемы. Изначально у нас два типа файлов — <strong>tracked</strong> и <strong>untracked</strong>, т.е. отслеживаемые и не отслеживаемые. Первые файлы находятся под контролем версий и они были в последнем слепке состояния, а вторые — нет.</p>

<p>Сохранение состояния называется — коммитом (коммит, <strong>commit</strong>, фиксация). Сленговое выражение закоммитить означает зафиксировать изменения. Если у вас несколько коммитов, то вы можете вернуться к любому из них или посмотреть состояние этого коммита и что было в нем.</p>

<p>Нам нужно сообщить Гиту что именно мы хотим сохранить. На последнем скриншоте выше сам git нам подсказывает что нужно сделать — <em>«git add» to track</em>. </p>

<p>Добавим один файл командой:</p>

<pre><code class="language-bash">git add index.html</code></pre>

<p> И посмотрим статус Гита:</p>

<pre><code class="language-bash">git status</code></pre>

<p>В итоге видим такую картину:</p>

<div>
<figure><img src="images/git-rep-2.jpg" alt="" class="img-fluid"></figure></div>

<p>Видим, что файл <em><strong>carousel.html</strong></em> стал зеленым и попал в изменения, для которых можно делать коммит, т.е. он проиндексирован. Мы можем проиндексировать все файлы командой:</p>

<pre><code class="language-bash">git add .</code></pre>

<p>В команде выше точка означает текущую папку. Если мы ставим точку, то git проиндексирует всю папку.</p>

<div class="attention-blue"><strong>Справка</strong>. В терминале Cmder можно очистить окно командой <strong><em>clear</em></strong>.</div>

<p>Убедимся, что все файлы проиндексированы:</p>

<div>
<figure><img src="images/git-rep-3.jpg" alt="" class="img-fluid"></figure></div>

<p>И вот теперь мы можем сделать наш первый коммит. Используем для этого комманду:</p>

<pre><code class="language-bash">git commit -m "first setup of the project"</code></pre>

<p>Флаг <code>-m</code> образуется от слова message (рус. — сообщение). Наше сообщение коротко описывает что было сделано в проекте до этого коммита.</p>

<p>Далее проверяем состояние командой:</p>

<pre><code class="language-bash">git status</code></pre>

<p>В терминале мы увидим следующие сообщения:</p>

<div>
<figure><img src="images/git-rep-4.jpg" alt="" class="img-fluid"></figure></div>

<p>Нам нечего коммитить и текущее состояние у нас сохранено.</p>

<p>Далее мы можем менять файлы. При этом можем использовать те редакторы, которые нам удобнее всего, например Vim.</p>

<div class="attention-blue"><strong>Справка</strong>. Удалить файл в терминале можно командой <strong><em>rm</em></strong> — от англ. remove, а если вы хотите удалить каталог со всеми подкаталогами и файлами в нем, используйте опцию <strong><em>-R</em></strong>.</div>

<p>Давайте откроем файл стилей в Vim:</p>

<pre><code class="language-bash">$ vim style.css</code></pre>

<p>Если вы не внесли никаких изменений и решили выйти из Vim, то нужно нажать последовательно <strong><em>Esc</em></strong>, затем <strong><em>:</em></strong> (двоеточие) и после написать <code>q!</code>.</p>

<p>Если вы внесли изменения и хотите их сохранить, то последовательно нажимаем <strong><em>Esc</em></strong>, потом <strong><em>:</em></strong> и после пишем: <em><strong>conf q</strong></em>. Жмем Enter. И теперь можем проверить, что изменилось:</p>

<pre><code class="language-bash">$ git status</code></pre>

<p>Видим, что файл был изменен — modified и выделен красным:</p>

<div>
<figure><img src="images/git-rep-5.jpg" alt="" class="img-fluid"></figure></div>

<p>Чтобы узнать что было изменено в файле мы используем команду:</p>

<pre><code class="language-bash">$ git diff</code></pre>

<p>Здесь <strong>diff</strong> происходит от англ. слова difference (рус. — разница).</p>

<div>
<figure><img src="images/git-rep-6.jpg" alt="" class="img-fluid"></figure></div>

<p>Здесь мы видим информацию в каком файле произошли изменения и какие строки были удалены (выделено красным) и добавлены (выделены зеленым).</p>

<p>Если изменения были в двух файлах, то терминал выведет их друг за другом.</p>

<p>Теперь мы можем сохраниться. Сначала индексируем измененные файлы:</p>

<pre><code class="language-bash">$ git add carousel.html
// можно использовать также команду: git add .</code></pre>

<p>Проверяем изменения командой <strong><em>git status</em></strong> и снова сделаем коммит:</p>

<pre><code class="language-bash">$ git commit -m "Changed title"</code></pre>

<p>Стоит ли делать коммиты чаще? Всё зависит от вас, но лучше всего делать коммиты тогда, когда изменения обрели какую-то законченную форму.</p>

<p>История коммитов нам покажет команда:</p>

<pre><code class="language-bash">$ git log</code></pre>

<p>Мы увидим два коммита для моего примера:</p>

<div>
<figure><img src="images/git-rep-7.jpg" alt="" class="img-fluid"></figure></div>

<p>Здесь мы видим идентификатор для каждого коммита. Этот идентификатор еще называют словом <strong>хеш</strong>. Если коммитов много, то листаем в терминале коммиты стрелками. Закрыть лог можно клавишей <strong><em>q</em></strong>.</p>

<p>Копируем хеш коммита и вводим команду, чтобы посмотреть конкретный коммит:</p>

<pre><code class="language-bash">$ git show 38a77c799f59acaa120cc4e984c8474fade5b633</code></pre>

<p>Мы увидим те изменения, которые были сделаны и сохранены.</p>

<p>Также жмем <strong><em>q</em></strong> для выхода.</p>

<h2><span id="Otkatyvaem_izmenenia">Откатываем изменения</span></h2>

<p>Рассмотрим в этом уроке что делать, если что-то пошло не так и как «откатить» сделанные изменения в сервисе контроля версий Git.</p>

<p>По традиции текущее состояние мы узнаем командой:</p>

<pre><code class="language-bash">$ git status</code></pre>

<p>Если мы видим, что какой-то файл находится в статусе <strong>modified</strong> и отмечен красным цветом,  то нам нужно посмотреть какие изменения были сделаны в файле или файлах:</p>

<pre><code class="language-bash">$ git diff</code></pre>

<p>Откатить изменения можно командой:</p>

<pre><code class="language-bash">$ git checkout &lt;file_name&gt;</code></pre>

<p>И теперь если мы проверим статус гита, то не увидим никаких предупреждений о модифицированном файле.</p>

<p>Можно также восстановить удаленный файл, если он был закоммичен ранее. </p>

<p>К примеру, если мы удалим файл, то проверка статуса Git покажет, что файл отмечен словом <strong><em>deleted</em></strong>. Восстановить его можно этой же командой:</p>

<pre><code class="language-bash">$ git checkout &lt;file_name&gt;</code></pre>

<p>Команда <strong>checkout</strong> возвращает состояние файла до последнего коммита, но вернуть состояние до <strong>checkout</strong> мы уже не сможем. Всё что вы не коммитили — потеряется, поэтому сбрасываете только те изменения, которые вам не нужны.</p>

<p>Мы можем также вернуть состояние файла до какого-либо коммита. Для этого нам нужно знать хеш коммита, который мы можем посмотреть после использования команды:</p>

<pre><code class="language-bash">$ git log</code></pre>
<p>Копируем хеш нужного нам коммита и вводим команду в консоли:</p>

<pre><code class="language-bash">$ git checkout &lt;commit_hash&gt; &lt;file_name&gt;</code></pre>

<p>Заменяем <code>&lt;commit_hash&gt;</code> на хеш коммита, а <code>&lt;file_name&gt;</code> на имя нужного файла, состояние которого мы хотим вернуть.</p>

<p>После чего мы смотрим статус и видим, что наш файл изменен и уже проиндексирован.</p>

<div>
<figure><img src="images/git-otkat-1.jpg" alt="" class="img-fluid"></figure></div>

<p>Нам нужно посмотреть изменения в этом файле. Мы используем знакомую нам команду <strong><em>diff</em></strong>, но с использованием дополнительного флага <strong><em>—staged</em></strong>:</p>

<pre><code class="language-bash">$ git diff --staged</code></pre>

<p>Команда <strong><em>diff</em></strong> нам показывала не проиндексированные изменения, а добавление флага нам позволяет смотреть проиндексированные изменения. Индекс часто называют «staged area».</p>

<p>Теперь мы можем делать коммит знакомой нам командой:</p>

<pre><code class="language-bash">$ git commit -m "your message here"</code></pre>

<p>Теперь допустим ситуацию, когда вы подготовили изменения к коммиту и добавили их в индекс, но решили, что один из файлов не нужен в индексе. Как удалить его из индекса?</p>

<p>К примеру, у нас есть два файла в статусе <strong>modified</strong> — <em>index.html</em> и <em>main.css</em>, и при этом мы не хотим включать <em>index.html</em> в коммит. Тогда мы используем следующую команду:</p>

<pre><code class="language-bash">$ git reset HEAD index.html</code></pre>

<p>После проверим статус и увидим следующее:</p>

<div>
<figure><img src="images/git-rep-8.jpg" alt="" class="img-fluid"></figure></div>

<p>Статус нам показывает, что изменения в <em>main.css</em> проиндексированы, а в <em>index.html</em> не проиндексированы. И если мы сделаем коммит, то в него попадут только изменения в <em>main.css</em>.</p>

<div>
<figure><img src="images/git-rep-9.jpg" alt="" class="img-fluid"></figure></div>

<p>На скриншоте команда status показывает, что изменения файла <em>index.html</em> не проиндексированы.</p>

<p>Теперь мы можем проиндексировать этот файл и сделать коммит. Так делать удобно, когда мы хотим сделать коммиты для разных целей, как в данном случае, когда мы сможем выбирать с чем работать потом — со стилями или с основным файлом.</p>

<p>Вводим далее:</p>

<pre><code class="language-bash">$ git add index.html
$ git commit -m "made changes in index file"</code></pre>

<p>Не забываем проверить статус и посмотреть лог. Также мы можем посмотреть изменения в конкретном коммите через команду show и хеш коммита:</p>

<pre><code class="language-bash">$ git show &lt;commit_hash&gt;</code></pre>

<p>Что если при создании коммита мы сделали ошибку в сообшении (подписи)? Возможно ли исправить ошибку? </p>

<p>Если мы увидели, что в последнем коммите есть ошибка в сообщении, то для начала мы используем команду:</p>

<pre><code class="language-bash">$ git log -1</code></pre>

<p>Флаг <code>-1</code> говорит терминалу показать только последний коммит, а флаг <code>-2</code> показывает два коммита, <code>-3</code> — три и т.д. </p>

<p>Чтобы исправить сообщение коммита мы используем команду:</p>

<pre><code class="language-bash">$ git commit --amend -m "correct message"</code></pre>

<p>Параметр amend позволяет изменить последний коммит.</p>

<p>Кроме изменения в сообщения изменяется также и хеш коммита, что говорит нам о том, что по-сути мы создали новый коммит. </p>

<p>Также есть возможность удалить из коммита лишний файл. Для этого мы используем команду:</p>

<pre><code class="language-bash">$ git rm &lt;file_name&gt;</code></pre>

<p>Если после этой команды мы посмотрим гит статус, то увидим, что файл будет помечен как <strong>deleted</strong> (рус. — удаленный). Теперь мы применяем команду:</p>

<pre><code class="language-bash">$ git commit --amend --no-edit</code></pre>

<p>В данном случае опять хеш коммита изменится. </p>

<p>В этом примере мы удалил файл из коммита и из папки, но бывают ситуации, когда файл нужно исключить из коммита, но не удалять из папки. Для этого мы используем команду:</p>

<pre><code class="language-bash">$ git rm --cached &lt;file_name&gt;</code></pre>

<p>Теперь мы увидим следующее:</p>

<div>
<figure><img src="images/git-otkat-2.jpg" alt="" class="img-fluid"></figure></div>

<p>Видим, что файл <em>test.css</em> одновременно в статусе <strong>deleted</strong> и <strong>untracked</strong> (рус. — не отслеживается). Используем команду:</p>

<pre><code class="language-bash">$ git commit --amend --no-edit</code></pre>

<p>Теперь файл не находится в коммите, но не удален из папки.</p>

<p>Если вам нужно посмотреть информацию про разные команды гита, то вы можете использовать команду <strong>help</strong>:</p>

<pre><code class="language-bash">$ git help checkout</code></pre>

<p>Команда выше покажет справку по команде <strong>checkout</strong>, что с ней можно делать и какие флаги (опции) с ней можно использовать. Листать справку можно стрелками с клавиатуры вверх и вниз.</p>

<h2><span id="Sozdanie_vetok_i_vetvlenia_v_GitHub">Создание веток и ветвления в GitHub</span></h2>

<p>В этом уроке мы поговорим про создание веток и ветвления в системе контроля версий Git.</p>

<p>Ветки, по своей сути, это две разных истории одного проекта. Ветвления и ветки являются самыми важными элементами Git. </p>

<p>Благодаря им вы всегда можете вернуться назад и отменить ошибки, сможете параллельно в команде работать над одним проектом. Каждый член команды сможет работать в своей ветке.</p>

<p>Давайте посмотрим наш лог коммитов:</p>

<pre><code class="language-bash">$ git log --oneline</code></pre>

<p>В предыдущих уроках мы использовали команду <strong>log</strong> без опций или с опцией <code>-1</code>, например. Здесь же мы добавили параметр <code>--oneline</code>. Он выводит коммит в одну строку, а не в пять, как при обычной комманде.</p>

<p>Давайте посмотрим один из коммитов:</p>

<pre><code class="language-bash">$ git cat-file -p c39a182</code></pre>

<p>Параметр <code>-p</code> мы добавили для удобства чтения. Коммит хранит информацию о том, кто и когда его сохрани, а также хеш родительского коммита.</p>

<p>При этом самый первый коммит не будет содержать родительского коммита. </p>

<p>Теперь нам снова понадобится команда <strong>checkout</strong>. Мы ее уже использовали в предыдущих уроках. Изначально команда&nbsp;<strong>checkout</strong>&nbsp;возвращает состояние файла до последнего коммита. </p>

<p>Если мы хотим перейти к какому-то коммиту на более ранних стадиях разработки, то вводим команду:</p>

<pre><code class="language-bash">$ git checkout &lt;commit_hash&gt;</code></pre>

<p>Где вместо <code>&lt;commit_hash&gt;</code> вводим имя нужного нам коммита, который мы посмотрели командой <strong>log</strong>.</p>

<p>Если после этой команды мы решим посмотреть историю через команду <strong>log</strong>, то увидим историю только до этого коммита, на который мы переключились. </p>

<p>Здесь важно понимать, что все коммиты никуда не исчезли на данном этапе,  просто сама история показывается до последнего коммита.</p>

<p>Теперь можно вернуться к последнему коммиту через команду:</p>

<pre><code class="language-bash">$ git checkout &lt;commit_hash&gt;</code></pre>

<p>Но что если мы забыли или потеряли хеш последнего коммита? Это не страшно. В Git есть кодовое слово указатель <strong>master</strong>. Этот указатель приписывается последнему самому новому коммиту.</p>

<p>При этом мы можем задавать указатели любому коммиту. Вводим команду:</p>

<pre><code class="language-bash">$ git checkout -b &lt;commit_name&gt; &lt;commit_hash&gt;</code></pre>

<p>В терминале мы увидим:</p>

<div>
<figure><img src="images/git-vetki-1.jpg" alt="" class="img-fluid"></figure></div>

<p>Теперь, если мы посмотрим стату Git:</p>

<pre><code class="language-bash">$ git status</code></pre>

<p>То увидим, что нам консоль вывела следующее:</p>

<div>
<figure><img src="images/git-vetki-2.jpg" alt="" class="img-fluid"></figure></div>

<p>Ключевая фраза здесь в примере — <em>On branch yellow-design</em>. Нам это говорит о том, что мы теперь находимся на коммите <strong>yellow-design</strong>.</p>

<p>Проверяем командой:</p>

<pre><code class="language-bash">$ git log --oneline --all</code></pre>

<p>В консоли увидим следующее:</p>

<div>
<figure><img src="images/git-vetki-3.jpg" alt="" class="img-fluid"></figure></div>

<p>Здесь можно наблюдать и <strong>master</strong> и <strong>HEAD -&gt; yellow-design</strong>. Слово HEAD указывает текущее положение и слово HEAD всегда в искусственном положении.</p>

<p>Что будет если изменить какие то файлы и закоммитить? Давайте изменим файл, проиндексируем его и создадим коммит.</p>

<div>
<figure><img src="images/git-vetki-4.jpg" alt="" class="img-fluid"></figure></div>

<p>Смотрим лог:</p>

<div>
<figure><img src="images/git-vetki-5.jpg" alt="" class="img-fluid"></figure></div>

<p>Куда-то делись другие коммиты, которые были после <strong>yellow-design</strong>. Здесь нам нужно использовать команду log с определенными опциями, чтобы увидеть всю картину целиком:</p>

<pre><code class="language-bash">$ git log --online --all --graph</code></pre>
<p>Мы выводим весь лог коммитов в одну строчку (<code>--oneline</code>), все коммиты (<code>--all</code>) и в виде наглядного графика (<code>--graph</code>).</p>
<div>
<figure><img src="images/git-vetki-6.jpg" alt="" class="img-fluid"></figure></div>

<p>Видим на скриншоте, что история коммитов раздвоилась, т.е. в проекте у нас теперь две ветки после коммита с хешем <strong>bc00f9f</strong>.</p>

<p>Наглядно это выглядит так:</p>

<div>
<figure><img src="images/git-vetki-7.jpg" alt="" class="img-fluid"></figure></div>

<p>Веткой называют всю историю коммитов, приводящих в текущую точку. Для <strong>master</strong> это такая ветка:</p>

<div>
<figure><img src="images/git-vetki-8.jpg" alt="" class="img-fluid"></figure></div>

<p>Для ветки yellow-design из нашего примера ветка такая:</p>

<div>
<figure><img src="images/git-vetki-9.jpg" alt="" class="img-fluid"></figure></div>

<p>Командой checkout можно перемещаться в любой коммит используя хеш или указатель ветки.</p>

<p>Выполнив команду <strong><em>git checkout master</em></strong> мы перейдем у точку с указателем <strong>master</strong>.</p>

<p>Можно создавать сколько угодно веток и коммитов. В итоге можем получить что-то вроде такого:</p>

<div>
<figure><img src="images/git-vetki-10.jpg" alt="" class="img-fluid"></figure></div>

<p>Но Git был бы не столь эффективен, если бы не было возможности объединять ветки. Давайте посмотрим на наше состояние проекта у которого две ветки:</p>

<div>
<figure><img src="images/git-vetki-11.jpg" alt="" class="img-fluid"></figure></div>
<p>Нам нужно теперь объединить коммиты из отдельных веток, но нам, также, нужно не потерять все изменения. </p>

<p>Нам понадобится для этого процедура мёрдж (англ. — <strong>merge</strong> или слияние). После слияния у нас будет один новый коммит, у которого будет два родителя.</p>
<div>
<figure><img src="images/git-vetki-12.jpg" alt="" class="img-fluid"></figure></div>

<p>Как мы видим — у нас два указателя и в новый коммит переместится указатель той ветки в которой мы находились.</p>

<p>Убедимся командой <em><strong>git status</strong></em>, что мы находимся в ветке <strong>master</strong>. И после этого мы должны влить ветку <strong>yellow-design</strong> в ветку <strong>master</strong>.</p>

<pre><code class="language-bash">$ git merge yellow-design -m "your message"</code></pre>

<p>В терминале выведется:</p>

<div>
<figure><img src="images/git-vetki-13.jpg" alt="" class="img-fluid"></figure></div>

<p>Теперь смотрим лог:</p>

<div>
<figure><img src="images/git-vetki-14.jpg" alt="" class="img-fluid"></figure></div>

<p>Мы можем создать новую ветку не указав хеш из текущего коммита:</p>

<pre><code class="language-bash">$ git checkout -b &lt;commit_name&gt;</code></pre>

<p>После этой команды мы можем переключаться между master и новым указателем (<code>&lt;commit_name&gt;</code>). Если мы сделаем новый коммит, то сдвинется указатель той ветки в которой мы находимся.</p>

<p>Вернуться в ветку <strong>master</strong> можно командой:</p>

<pre><code class="language-bash">$ git checkout master</code></pre>

<p>Обычно при командной разработке ветку <strong>master</strong> считают основной, даже если в проекте много других веток.</p>

<h2><span id="Konflikty_i_osibki">Конфликты и ошибки</span></h2>

<p>Рассмотрим возможности разрешения конфликтов при работе в системой контроля версий Git.</p>

<p>Чаще всего конфликты возникают при слиянии веток. Например, когда один и тот же файл проекта менялся по разному в разных ветках. В одной ветке вы в файле удалили строчку, а в ветке <strong>master</strong> вы изменили эту же строчку в этом же файле.</p>

<p>При слиянии этих двух веток возникнет конфликт, т.к. Git не способен за вас решить какие из всех изменений более правильные и не будет сливать ветки автоматически. Git предложит вам разрешить конфликт.</p>

<p>Давайте попробуем слить две ветки из нашего примера командой:</p>

<pre><code class="language-bash">$ git merge &lt;commit_name&gt;</code></pre>

<p>Получим следующее сообщение:</p>

<div>
<figure><img src="images/git-konflikt-1.jpg" alt="" class="img-fluid"></figure></div>

<p>Где видно, что Git предупреждает о конфликте: <em>Merge conflict in index.html</em>. Также на скриншоте видно, что в файлом <em><strong>css/button.css</strong></em> всё прошло хорошо и слияние было успешным.</p>

<p>Проверяем всё командой:</p>

<pre><code class="language-bash">$ git status</code></pre>

<p>При этом Гит нам подсказывает что можно сделать:</p>

<div>
<figure><img src="images/git-konflikt-2.jpg" alt="" class="img-fluid"></figure></div>

<p>Он рекомендует исправить конфликты и закоммитить результат: <em><strong>fix conflicts and run «git commit»</strong></em>.</p>

<p>Мы видим для файла index.html статус <strong>both modified</strong>. Это значит, что он изменен в обоих ветках.</p>

<p>Открываем файл в редакторе.</p>

<pre><code class="language-bash">$ vim index.html</code></pre>

<p>Вот как будет выглядеть файл в редакторе Vim:</p>

<div>
<figure><img src="images/git-konflikt-3.jpg" alt="" class="img-fluid"></figure></div>

<p>В файле появились какие-то непонятные символы — стрелки, равно и указатели HEAD и search-page (выделено на скриншоте серым цветом). Так выглядит типичный конфликт.</p>

<p>Код между угловыми скобками и до равно — это код в файле в ветке в которой мы находимся. А после равно и до вторых угловых скобок — код в ветке, которую мы хотим слить с основной.</p>

<p>Нам нужно выбрать один из вариантов или оставить оба варианта и удалить все эти разделители. После этого мы сохраняем файл и делаем коммит.</p>

<pre><code class="language-bash">$ git add index.html
$ git commit -m "merged search-page to master"</code></pre>

<p>Далее посмотрим что у нас получилось:</p>

<pre><code class="language-bash">$ git log --oneline --graph -6</code></pre>

<p>Получаем такой лог:</p>

<div>
<figure><img src="images/git-konflikt-4.jpg" alt="" class="img-fluid"></figure></div>

<p>Мёрдж прошел успешно, что мы видим в логе там где HEAD.</p>

<p>Если есть конфликт в ситуации когда в одной ветке файл удален, а в другой изменен, то этот конфликт разрешается таким же образом.</p>

<p>Например, у нас такая ситуация и <strong>git status</strong> показывает следующее:</p>

<div>
<figure><img src="images/git-konflikt-5.jpg" alt="" class="img-fluid"></figure></div>

<p>Здесь у нас странный статус: <em><strong>deleted by us</strong></em> (рус. — удален нами). Текущая ветка по мнению Гит — мы (us), а ветку, которую мы вливаем, — они (they).</p>

<p>В итоге, для разрешения конфликта нам нужно либо удалить файл, либо сохранить.</p>

<p>Если мы оставляем файл, то используем команду:</p>

<pre><code class="language-bash">$ git add &lt;file_name&gt;</code></pre>

<p>Если мы хотим удалить файл из индекса, то используем известную нам команду <strong>rm</strong>:</p>

<pre><code class="language-bash">$ git rm &lt;file_name&gt;</code></pre>

<p>После этого делаем коммит и дальше проверяем лог командой:</p>

<pre><code class="language-bash">$ git log --oneline --graph -5</code></pre>

<p>Конфликт разрешен. Всё хорошо. Решать конфликты не сложно.</p>

<h2><span id="Otpravlaem_kod_na_GitHub_i_nastraivaem_SSH-kluci">Отправляем код на GitHub и настраиваем SSH-ключи</span></h2>

<p>Рассмотрим как нам отправить код проекта на GitHub и настроить SSH-ключи для работы с системой контроля версий.</p>

<p>Большинство компаний используют разные сайты — GitHub, GitLab, BitBucket и др. Но мы будем использовать GitHub.</p>

<p>Переходим на сайт github.com и регистрируемся, если вы этого еще не сделали.</p>

<div class="attention-git"><a href="https://github.com/" target="_blank" rel="noreferrer noopener">GitHub.com</a></div>

<p>Вводим имя пользователя (Username), почту (Email) и пароль (Password). После чего Giyhub спросит про тариф. Выбираем бесплатный. Вы увидите фразу: <em>Unlimited public repositories for free</em>. Это то, что нам нужно. </p>

<p>В конце рассказываем про опыт и всё, регистрация завершена. Этот шаг можно пропустить.</p>

<p>Теперь мы можем опубликовать первый проект. Нажимаем <strong><em>Start a project</em></strong>.</p>

<div>
<figure><img src="images/github-1.jpg" alt="" class="img-fluid"></figure></div>

<p>И вводим имя нашего первого проекта и репозитория:</p>
<div>
<figure><img src="images/github-2.jpg" alt="" class="img-fluid"></figure></div>

<p>Далее выбираем тип репозитория — Публичный (public) или Приватный (private). Приватный репозиторий — платная услуга. Публичный репозиторий будет доступен всем в Интернете.</p>

<p>Дальше нас GitHub спросит про создание файла README для проекта. Мы не будем ставить галочку, т.к. у нас уже есть локальный проект с историей. </p>

<p>Теперь жмем <strong>Create Repository</strong> (создать репозиторий).</p>

<p>Репозиторий создан и мы сразу видим, что Github подсказывает что нам делать далее. У нас сразу есть возможность выбрать протокол — HTTPS или SSH. Мы выбираем SSH.</p>

<p>Т.к. у нас уже есть репозиторий локально, то нам нужно обращать внимание на команды в этом блоке: <strong><em>…or push an existing repository from the command line</em></strong>. Мы будем использовать команды из него.</p>

<p>Т.е. мы используем в Cmder команду:</p>

<pre><code class="language-bash">$ git remote add origin https://github.com/sergeiermilov/uzabila-carousel.git</code></pre>

<p>В удаленный репозиторий можно отправлять файлы и получать их из него.</p>

<p>Сама команда <code>git remote add</code> — добавляет удаленный репозиторий, а <code>origin</code> — общее признанное имя. Проверим, что репозиторий добавился:</p>

<pre><code class="language-bash">$ git remote -v</code></pre>

<p>Посмотрим что покажет терминал:</p>

<div>
<figure><img src="images/github-3.jpg" alt="" class="img-fluid"></figure></div>

<p>Git показал нам две origin строчки — fetch и push. Fetch — это мы можем забирать изменения, а Push — отправлять изменения.</p>

<p>Дальше GitHub нам рекомендовал команду:</p>

<pre><code class="language-bash">$ git push -u origin main
// или git push -u origin master</code></pre>

<p>Если вы увидели ошибку:</p>

<pre><code class="language-bash">error: src refspec master does not match any.  
error: failed to push some refs to 'ssh://xxxxx.com/project.git'</code></pre>

<p>То это, скорее всего, означает, что имя ветки не совпало с указанным в команде. Например в коде выше я ввел:</p>

<pre><code class="language-bash">$ git push -u origin main</code></pre>

<p>Хотя моя ветка называлась <strong>master</strong>.</p>

<p>Далее мы получаем ошибку:</p>

<pre><code class="language-bash">Permission denied (publickey).
Fatal: Could not read from remote repository.</code></pre>

<p>GitHub не может нас узнать, т.к. мы авторизованы в браузере, но не в консоли. Мы добавили репозиторий с протоколом SSH — протоколом безопасного соединения между компьютерами. Его используют не только на GitHub, так, через SSH системные администраторы управляют серверами.</p>

<p>Чтобы авторизоваться в GitHub по SSH нам нужно сгенерировать SSH-ключи — публичный и приватный. Приватный ключ нужно держать в секрете.</p>

<p>В домашней папке создаем папку <strong>.ssh</strong> и перейдем в нее:</p>

<pre><code class="language-bash">$ mkdir ~/.ssh
$ cd ~/.ssh</code></pre>

<p>Теперь генерируем пару ключей командой:</p>

<pre><code class="language-bash">$ ssh-keygen -t rsa -b 4096 -C "&lt;your_email&gt;"</code></pre>

<p>Пару ключей для Github мы генерируем только один раз. </p>

<p>Теперь нас спросят про название ключа, где пишем свое имя, т.к. лучше не использовать стандартное, которое предлагает терминал. После этого нас попросят указать пароль. Здесь мы можем оставить пароль пустым и нажать Enter. И теперь еще раз <strong>Enter</strong> для подтверждения пароля.</p>

<p>Теперь в папке <strong>.ssh</strong> будут два файла — один без расширения — приватный ключ, а второй с расширением <strong>.pub</strong> — публичный ключ.</p>

<div>
<figure><img src="images/github-4.jpg" alt="" class="img-fluid"></figure></div>

<p>Публичный ключ мы должны загрузить на Github и для этого мы переходим на сайт github.com и далее переходим в <strong>Настройки</strong> (Settings). В настройках выбираем пункт: <strong>SSH and GPG keys</strong>.</p>

<p>Жмем <strong>New SSH key</strong>.</p>

<p>Вводим название (title) и далее нам нужно в поле ключ (key) вставить содержимое ключа, которое мы скопируем из консоли после использования команды <strong>cat</strong>, и здесь используем публичный ключ. В названии я использую имя компьютера на котором работаю, но можно вводить что угодно.</p>

<div>
<figure><img src="images/github-5.jpg" alt="" class="img-fluid"></figure></div>

<p>Выделяем ключ (весь текст от слова ssh-… вместе с email), копируем его в Github и далее жмем <strong>Add SSH key</strong>:</p>

<div>
<figure><img src="images/github-6.jpg" alt="" class="img-fluid"></figure></div>

<p>Теперь нужно проверить, что github нас узнает (указываем приватный ключ):</p>

<pre><code class="language-bash">$ ssh -T -i ~/.ssh/&lt;file_name_private_key&gt; git@github.com</code></pre>

<p>Github с нами поздоровается:</p>

<div>
<figure><img src="images/github-7.jpg" alt="" class="img-fluid"></figure></div>

<p>Проверка связи с сайтом без приватного ключа приведет к ошибке:</p>

<pre><code class="language-bash">$ ssh -T git@github.com
// Ошибка: Permission denied (publickey)</code></pre>

<p>Чтобы при соединении с GitHub всегда использовался нужный ключ мы должны в настройках SSH указать этот ключ. Настройки SSH хранятся в папке <strong>.ssh</strong> и в файле <strong>config</strong> локального домашнего пользователя. Добавляем информацию об использовании для хоста github.com определенный ключ:</p>

<pre><code class="language-bash">Host github.com
	IdentityFile ~/.ssh/&lt;key_file_name&gt;</code></pre>

<p>Обратите внимание на отступ во второй строке и что используется приватный ключ:</p>

<div>
<figure><img src="images/git-ssh-13.jpg" alt="" class="img-fluid"></figure></div>

<p>Теперь заново пробуем соединиться с гитхабом:</p>

<pre><code class="language-bash">$ ssh -T git@github.com</code></pre>

<p>Теперь всё получилось:</p>

<div>
<figure><img src="images/github-8.jpg" alt="" class="img-fluid"></figure></div>

<p>Теперь мы можем вернуться в репозиторий и отправить изменения на GitHub:</p>

<pre><code class="language-bash">$ git push -u origin master</code></pre>

<p>Если перейти на Гитхаб и посмотреть репозиторий, то мы увидим все файлы, которые были отправлены из локального репозитория.</p>

<h2><span id="Proverka_SSH-soedinenia_s_GitHub">Проверка SSH-соединения с GitHub</span></h2>

<p>После того, как вы настроили свой SSH-ключ и добавили его в свою учетную запись GitHub, вы можете проверить свое соединение.</p>

<p>Перед проверкой SSH-соединения вы можете сделать:</p>

<ol>
<li>Проверку существующих ключей SSH</li>
<li>Создать новый ключ SSH и добавить его в ssh-agent</li>
<li>Добавить новый SSH-ключ в вашу учетную запись GitHub</li>
</ol>

<h3><span id="Proverka_susestvuusih_klucej_SSH">Проверка существующих ключей SSH</span></h3>

<p>Перед тем, как сгенерировать SSH-ключ, вы можете проверить, есть ли у вас существующие SSH-ключи.</p>

<div class="attention-blue"><strong>Примечание</strong>. Ключи DSA (SSH-DSS) больше не поддерживаются. Существующие ключи будут продолжать работать, но вы не сможете добавлять новые ключи DSA в свою учетную запись GitHub.</div>

<style>
.tab {
  overflow: hidden;
  border: none;
  box-shadow: inset 0 -2px 0 #e1e4e8;
  background-color: #fff;
}
.tab button {
  font-weight: 600;  
  float: left;  
  cursor: pointer;
  padding: 14px 16px;
  border:none;
  border-bottom: 2px solid #dfdfdf;
  background-color: #fff;
  outline: 0;
}
.tab button:hover {
  border-bottom: 2px solid #565656;
}

.tab button:focus, .tab button:active{
  outline: 0;
}
.tab button.active {
  background-color: #efefef;
  border-bottom: 2px solid #f9826c;
  transition: border-bottom-color .36s ease-in;
}
.tabcontent {
  display: none;
  padding: 18px 0 0;
}
</style>
<div class="tab">
  <button class="tablinks" onclick="openCity(event, 'London')" id="defaultOpen">Mac</button>
  <button class="tablinks" onclick="openCity(event, 'Paris')">Windows</button>
  <button class="tablinks" onclick="openCity(event, 'Tokyo')">Linux</button>
</div>
<div id="London" class="tabcontent">
  <p>1. Откройте Терминал (Terminal).</p>
</div>
<div id="Paris" class="tabcontent">
  <p>1. Откройте Git Bash.</p> 
</div>
<div id="Tokyo" class="tabcontent">
  <p>1. Откройте Терминал (Terminal)</p>
</div>
<script>
function openCity(evt, cityName) {
  let i, tabcontent, tablinks;
  tabcontent = document.getElementsByClassName("tabcontent");
  for (i = 0; i < tabcontent.length; i++) {
    tabcontent[i].style.display = "none";
  }  
  tablinks = document.getElementsByClassName("tablinks");
  for (i = 0; i < tablinks.length; i++) {
    tablinks[i].className = tablinks[i].className.replace(" active", "");
  }
  document.getElementById(cityName).style.display = "block";
  evt.currentTarget.className += " active";   
}
document.getElementById("defaultOpen").click();
</script>

<p>2. Введите <code>ls -al ~/.ssh</code>, чтобы узнать, есть ли существующие ключи SSH:</p>

<pre><code class="language-bash">$ ls -al ~/.ssh
# Lists the files in your .ssh directory, if they exist</code></pre>

<p>Проверьте список каталогов, чтобы увидеть, есть ли у вас уже публичный SSH ключ. По умолчанию, имена файлов публичных ключей являются одними из следующих:</p>

<ul>
<li><em>id_rsa.pub</em></li>
<li><em>id_ecdsa.pub</em></li>
<li><em>id_ed25519.pub</em></li>
</ul>

<p>Если у вас нет существующей пары публичных и приватных ключей, или вы не хотите использовать любую доступную пару для подключения к GitHub, сгенерируйте новый SSH-ключ.</p>

<p>Если вы видите существующую пару публичных и приватных ключей (например, <strong>id_rsa.pub</strong> и <strong>id_rsa</strong>), которые вы хотите использовать для подключения к GitHub, вы можете добавить SSH-ключ в ssh-agent.</p>

<div class="attention-blue"><strong>Подсказка</strong>. Если вы получили ошибку, что <strong>~/.ssh</strong> не существует, не волнуйтесь! Мы создадим его, когда сгенерируем новый SSH-ключ.</div>

<h3><span id="Sozdanie_novogo_kluca_SSH_i_dobavlenie_ego_v_ssh-agent">Создание нового ключа SSH и добавление его в ssh-agent</span></h3>

<p>После того, как вы проверили существующие SSH ключи, вы можете сгенерировать новый SSH ключ для аутентификации, затем добавить его в ssh-agent.</p>

<p>Если у вас еще нет SSH ключа, вы должны сгенерировать новый SSH ключ. Если вы не уверены, есть ли у вас уже SSH-ключ, проверьте существующие ключи.</p>

<p>Если вы не хотите вводить вашу ключевую фразу каждый раз, когда вы используете SSH-ключ, вы можете добавить ваш ключ к SSH-агенту, который управляет вашими SSH-ключами и запоминает вашу ключевую фразу.</p>

<style>
.tab-ssh {
  overflow: hidden;
  border: none;
  box-shadow: inset 0 -2px 0 #e1e4e8;
  background-color: #fff;
}
.tab-ssh button {
  font-weight: 600;  
  float: left;  
  cursor: pointer;
  padding: 14px 16px;
  border:none;
  border-bottom: 2px solid #dfdfdf;
  background-color: #fff;
  outline: 0;
}
.tab-ssh button:hover {
  border-bottom: 2px solid #565656;
}

.tab-ssh button:focus, .tab-ssh button:active{
  outline: 0;
}
.tab-ssh button.active {
  background-color: #efefef;
  border-bottom: 2px solid #f9826c;
  transition: border-bottom-color .36s ease-in;
}
.tabcontent-ssh {
  display: none;
  padding: 18px 0 0;
}
</style>
<div class="tab-ssh">
  <button class="tablinks-ssh" onclick="openTown( event, 'First')" id="defaultOpenSsh">Mac</button>
  <button class="tablinks-ssh" onclick="openTown( event, 'Second')">Windows</button>
  <button class="tablinks-ssh" onclick="openTown( event, 'Third')">Linux</button>
</div>
<div id="First" class="tabcontent-ssh">
  <p>1. Откройте Терминал (Terminal).</p>
</div>
<div id="Second" class="tabcontent-ssh">
  <p>1. Откройте Git Bash.</p> 
</div>
<div id="Third" class="tabcontent-ssh">
  <p>1. Откройте Терминал (Terminal)</p>
</div>
<script>
function openTown( act, city) {
  let j, tabcontentSsh, tablinksSsh;
  
  tabcontentSsh = document.getElementsByClassName("tabcontent-ssh");
  for (j = 0; j < tabcontentSsh.length; j++) {
    tabcontentSsh[j].style.display = "none";
  }  
  tablinksSsh = document.getElementsByClassName("tablinks-ssh");
  for (j = 0; j < tablinksSsh.length; j++) {
    tablinksSsh[j].className = tablinksSsh[j].className.replace(" active", "");
  }
  document.getElementById(city).style.display = "block";
  act.currentTarget.className += " active";   
}
document.getElementById("defaultOpenSsh").click();
</script>

<p>2. Вставьте текст ниже, подставив свой адрес электронной почты на GitHub.</p>

<pre><code class="language-bash">$ ssh-keygen -t rsa -b 4096 -C "your_email@example.com"</code></pre>

<p>Это создает новый ключ ssh, используя указанный адрес электронной почты в качестве метки.</p>

<pre><code class="language-bash">&gt; Generating public/private rsa key pair.</code></pre>

<p>Когда появится запрос «Ввести файл, в котором нужно сохранить ключ», нажмите Enter. При этом принимается расположение файла по умолчанию.</p>

<pre><code class="language-bash">&gt; Enter a file in which to save the key (/c/Users/you/.ssh/id_rsa):[Press enter]</code></pre>

<p>В приглашении введите защищенную ключевую фразу. Дополнительную информацию мы осветим в следующей статье по Git — «Работа с ключевыми фразами SSH».</p>

<pre><code class="language-bash">&gt; Enter passphrase (empty for no passphrase): [Type a passphrase]
&gt; Enter same passphrase again: [Type passphrase again]</code></pre>

<h3><span id="Dobavlenie_vasego_SSH-kluca_v_ssh-agent_na_GitHub">Добавление вашего SSH-ключа в ssh-agent на GitHub</span></h3>

<p>Перед добавлением нового SSH-ключа в ssh-agent для управления вашими ключами, вы должны были проверить существующие SSH-ключи и сгенерировать новый SSH-ключ.</p>

<p>Если у вас установлен GitHub Desktop (для рабочего стола), то вы можете использовать его для клонирования репозиториев и не работать с SSH-ключами.</p>

<p>Убедитесь, что ssh-agent запущен. Или вы можете запустить его вручную:</p>

<pre><code class="language-bash"># start the ssh-agent in the background
$ eval $(ssh-agent -s)
&gt; Agent pid 59566</code></pre>

<p>Добавьте ваш приватный ключ SSH к ssh-agent. Если вы создали ключ с другим именем, или если вы добавляете существующий ключ с другим именем, замените id_rsa в команде на имя файла с вашим приватным ключом.</p>

<pre><code class="language-bash">$ ssh-add ~/.ssh/id_rsa</code></pre>

<p>Далее нужно добавить ключ SSH в свою учетную запись GitHub.</p>

<h3><span id="Dobavlenie_kluca_SSH_v_svou_ucetnuu_zapis_GitHub">Добавление ключа SSH в свою учетную запись GitHub</span></h3>

<p>Чтобы настроить учетную запись GitHub для использования нового (или существующего) ключа SSH, вам также необходимо добавить его в свою учетную запись GitHub.</p>

<p>Прежде чем добавлять новый SSH-ключ в вашу учетную запись GitHub, вы должны были:</p>

<ul>
<li>проверить наличие существующих ключей SSH;</li>
<li>сгенерировать новый ключ SSH и добавить его в ssh-agent.</li>
</ul>

<p>После добавления нового ключа SSH в свою учетную запись GitHub вы можете перенастроить любые локальные репозитории для использования SSH. Про переключение удаленных URL-адресов с HTTPS на SSH мы поговорим в следующих статьях.</p>

<div class="attention-blue"><strong>Примечание</strong>. Ключи DSA (SSH-DSS) больше не поддерживаются. Существующие ключи будут продолжать работать, но вы не сможете добавить новые ключи DSA в свою учетную запись GitHub.</div>

<p>1. Скопируйте ключ SSH в буфер обмена.</p>

<p>Если ваш SSH-файл ключа имеет другое имя, чем в примере, измените имя файла, чтобы оно совпадало с вашими текущими настройками. При копировании ключа не добавляйте новые строки или пробелы.</p>

<p><strong>Mac</strong></p>

<pre><code class="language-bash">$ pbcopy &lt; ~/.ssh/id_rsa.pub
# Copies the contents of the id_rsa.pub file to your clipboard</code></pre>

<div class="attention-blue"><strong>Совет</strong>. Если <code>pbcopy</code> не работает, вы можете найти скрытую папку <strong>.ssh</strong>, открыть файл в своем любимом текстовом редакторе и скопировать его в буфер обмена.</div>

<p><strong>Windows</strong></p>

<pre><code class="language-bash">$ clip &lt; ~/.ssh/id_rsa.pub
# Copies the contents of the id_rsa.pub file to your clipboard</code></pre>

<div class="attention-blue"><strong>Совет</strong>. Если <code>clip</code> не работает, вы можете найти скрытую папку <strong>.ssh</strong>, открыть файл в любимом текстовом редакторе и скопировать его в буфер обмена.</div>

<p><strong>Linux</strong></p>

<pre><code class="language-bash">$ sudo apt-get install xclip
# Downloads and installs xclip. If you don't have `apt-get`, you might need to use another installer (like `yum`)

$ xclip -selection clipboard &lt; ~/.ssh/id_rsa.pub
# Copies the contents of the id_rsa.pub file to your clipboard</code></pre>

<div class="attention-blue"><strong>Совет</strong>. Если <code>xclip</code> не работает, вы можете найти скрытую папку <strong>.ssh</strong>, открыть файл в любимом текстовом редакторе и скопировать его в буфер обмена.</div>

<p>2. В правом верхнем углу любой страницы кликните на свою фотографию в профиле, затем нажмите кнопку <strong>Settings</strong> (Настройки).</p>

<div>
<figure><img src="images/git-settings.png" alt="" class="img-fluid"></figure></div>

<p>3. На боковой панели настроек пользователя нажмите «SSH и GPG ключи» (<strong>SSH and GPG keys</strong>).</p>

<div>
<figure><img src="images/git-ssh-keys.png" alt="" class="img-fluid"></figure></div>

<p>4. Нажмите кнопку «Новый SSH ключ» (<strong>New SSH key</strong>) или «Добавить SSH ключ».</p>

<div>
<figure><img src="images/git-dobavit-ssh-key.png" alt="" class="img-fluid"></figure></div>

<p>5. В поле «Заголовок» (<strong>Title</strong>) добавьте описательную метку для нового ключа. Например, если вы используете персональный Mac, вы можете назвать эту клавишу «Personal MacBook Air».</p>

<p>6. Вставьте свой ключ в поле «Ключ» (<strong>Key</strong>).</p>

<div>
<figure><img src="images/ssh-key-vstavka.png" alt="" class="img-fluid"></figure></div>

<p>7. Нажмите кнопку «Добавить SSH ключи» (<strong>Add SSH key</strong>).</p>

<div>
<figure><img src="images/ssh-add-key.png" alt="" class="img-fluid"></figure></div>


<p>8. Если появится форма подтверждения — подтвердите пароль GitHub.</p>

<div>
<figure><img src="images/github-ok.png" alt="" class="img-fluid"></figure></div>

<h3><span id="Proverka_soedinenia">Проверка соединения</span></h3>

<p>После того, как вы настроили свой SSH-ключ и добавили его в свою учетную запись GitHub, вы можете проверить соединение.</p>

<p>Перед тестированием вашего SSH соединения, вы должны были:</p>

<ul>
<li>проверить наличие существующих ключей SSH;</li>
<li>сгенерирован новый ключ SSH;</li>
<li>добавить новый SSH-ключ к учетной записи GitHub.</li>
</ul>

<p>Когда вы тестируете ваше соединение, вам нужно будет аутентифицировать это действие, используя ваш пароль, который является ключевой парольной фразой SSH, созданной вами ранее.</p>

<style>
.tab-ssh-new {
  overflow: hidden;
  border: none;
  box-shadow: inset 0 -2px 0 #e1e4e8;
  background-color: #fff;
}
.tab-ssh-new button {
  font-weight: 600;  
  float: left;  
  cursor: pointer;
  padding: 14px 16px;
  border:none;
  border-bottom: 2px solid #dfdfdf;  
  background-color: #fff;
  outline: 0;
}
.tab-ssh-new button:hover {
  border-bottom: 2px solid #565656;
}

.tab-ssh-new button:focus, .tab-ssh-new button:active{
  outline: 0;
}
.tab-ssh-new button.active {
  background-color: #efefef;
  border-bottom: 2px solid #f9826c;
  transition: border-bottom-color .36s ease-in;
}
.tabcontent-ssh-new {
  display: none;
  padding: 18px 0 0;
}
</style>
<div class="tab-ssh-new">
  <button class="tablinks-ssh-new" onclick="openNew( event, 'One')" id="defaultOpenSshNew">Mac</button>
  <button class="tablinks-ssh-new" onclick="openNew( event, 'Two')">Windows</button>
  <button class="tablinks-ssh-new" onclick="openNew( event, 'Three')">Linux</button>
</div>
<div id="One" class="tabcontent-ssh-new">
  <p>1. Откройте Терминал (Terminal).</p>
</div>
<div id="Two" class="tabcontent-ssh-new">
  <p>1. Откройте Git Bash.</p> 
</div>
<div id="Three" class="tabcontent-ssh-new">
  <p>1. Откройте Терминал (Terminal)</p>
</div>
<script>
function openNew( xyz, infos) {
  let h, tabcontentSshNew, tablinksSshNew;
  
  tabcontentSshNew = document.getElementsByClassName("tabcontent-ssh-new");
  for (h = 0; h < tabcontentSshNew.length; h++) {
    tabcontentSshNew[h].style.display = "none";
  }  
  tablinksSshNew = document.getElementsByClassName("tablinks-ssh-new");
  for (h = 0; h < tablinksSshNew.length; h++) {
    tablinksSshNew[h].className = tablinksSshNew[h].className.replace(" active", "");
  }
  document.getElementById(infos).style.display = "block";
  xyz.currentTarget.className += " active";   
}
document.getElementById("defaultOpenSshNew").click();
</script>

<p>2. Введите следующее:</p>

<pre><code class="language-bash">$ ssh -T git@github.com
# Attempts to ssh to GitHub</code></pre>

<p>Вы можете увидеть такое предупреждение:</p>

<pre><code class="language-bash">&gt; The authenticity of host 'github.com (IP ADDRESS)' can't be established.
&gt; RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.
&gt; Are you sure you want to continue connecting (yes/no)?</code></pre>

<p>или такое:</p>

<pre><code class="language-bash">&gt; The authenticity of host 'github.com (IP ADDRESS)' can't be established.
&gt; RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.
&gt; Are you sure you want to continue connecting (yes/no)?</code></pre>

<p>Убедитесь, что отпечаток (fingerprint) в сообщении, который вы видите, совпадает с одним из сообщений на шаге 2, затем введите <strong>yes</strong>:</p>

<pre><code class="language-bash">&gt; Hi username! You've successfully authenticated, but GitHub does not
&gt; provide shell access.</code></pre>

<p>Убедитесь, что полученное сообщение содержит ваше имя пользователя. Конечно, вы можете получить сообщение «разрешение отклонено», но об этом мы поговорим в следующих статьях.</p>

<h2><span id="Otpravka_pervogo_lokalnogo_proekta_na_GitHub">Отправка первого локального проекта на GitHub</span></h2>

<p>Одна из полезных привычек, которые я в себе последнее время воспитываю — это привычка работать с проектами и использовать Git даже в тех случаях, если проект создан локально и нужен, например, для обучения. Потому как мало ли что может вырасти в будущем даже из небольшого учебного проекта.</p>

<p>Рассмотрим отправку (push) своего первого проекта с локального компьютера в GitHub репозиторий.</p>

<h3><span id="Ubedites_cto_git_otslezivaet_vas_proekt">Убедитесь, что git отслеживает ваш проект</span></h3>

<p>1. Используя свой терминал (командную строку), зайдите в папку, где хранятся файлы вашего проекта: <code>cd /path/to/my/codebase</code>.</p>

<p>Я использую <strong>Cmder</strong> (официальный сайт — <em><strong>cmder.net</strong></em>) и очень доволен данным терминалом. Также, если вы используете для разработки на PHP Open Server (<em>ospanel.io</em>), то в нем есть встроенная консоль. </p>

<div class="attention-red">Важно понимать, что в Cmder есть две версии для скачивания и Git есть только в версии <strong>Full</strong>.</div>

<p>Вы не можете сделать это, просто открыв папку как обычно, вы должны сделать это с помощью командной строки / терминала.</p>

<p>2. Проверьте, инициализирован ли <strong>git</strong> командой <code>git status</code>.</p>

<p>Вы можете получить такое сообщение об ошибке:</p>

<pre><code class="language-bash">$ git
fatal: Not a git repository (or any of the parent directories): .git</code></pre>

<p>Это означает, что папка, в которой вы находитесь, не отслеживается git. В этом случае инициализируйте <strong>git</strong> внутри папки вашего проекта, набрав команду </p>

<pre><code class="language-bash">$ git init</code></pre>

<p>Если вы получили другое сообщение об ошибке, то внимательно на него посмотрите. Как правило, дополнительные ошибки появляется либо когда git не установлен на вашем компьютере, либо когда вы уже находитесь в папке или подпапке, где инициализируется git.</p>

<p>Если всё нормально, то далее выполните процесс добавления и «фиксации» вашего проекта — команды <code>git add</code> и <code>git commit</code>. Но об этом будем говорить дальше.</p>

<p>Напоминаю, что проверить настройки Git и пользователя в Cmder можно командой:</p>

<pre><code class="language-bash">$ cat ~/.gitconfig</code></pre>

<p>Тильда — это адрес вашего домашнего каталога.</p>

<div>
	<figure><img src="images/git-config.jpg" alt="" class="img-fluid">
	<figcaption class="wp-element-caption">Проверяем пользователя git локального компьютера</figcaption></figure>
</div>

<p>После инициализации Git нельзя удалять папку <code>.git</code>.</p>

<h3><span id="Sozdajte_udalennyj_repozitorij_na_Github">Создайте удаленный репозиторий на Github</span></h3>

<ol>
<li>Войдите в свою учетную запись Github.</li>
<li>В правом верхнем углу любой страницы Github вы должны увидеть значок «<strong>+</strong>». Нажмите на это, затем выберите ‘New Repository’ (рус. — Новый репозиторий).</li>
<li>Дайте вашему хранилищу имя — в идеале то же имя, что и у вашего локального проекта. Если я создаю приложение для путешествий, его папка будет называться «travel-app» на моем компьютере, а «travel-app» будет также именем репозитория Github.</li>
<li>Нажмите ‘Create Repository’ (рус. — Создать репозиторий). Следующий экран, который вы увидите, будет важен, поэтому не закрывайте его.</li>
</ol>

<h3><span id="Podklucite_lokalnuu_papku_proekta_k_vasemu_pustomu_hranilisu_na_Github">Подключите локальную папку проекта к вашему пустому хранилищу на Github</span></h3>

<p>Сейчас на сайте github вы видите страницу у которой в заголовке написано: «<strong>Quick setup — if you’ve done this kind of thing before</strong>«.</p>

<p>Скопируйте ссылку в поле формы (input) прямо под заголовком, она должна выглядеть примерно так:</p>

<pre><code class="language-bash">https://github.com/mindplace/test-repo.git</code></pre>

<p>Это веб-адрес (ссылка), который будет использовать ваша локальная папка для отправки содержимого в удаленную папку на Github.</p>

<p>1. Вернитесь к своему проекту в терминале / командной строке.</p>

<p>2. В вашем терминале / командной строке введите:</p>

<pre><code class="language-bash">$ git remote add origin [скопированная ссылка]</code></pre>

<p>Наш пример:</p>

<pre><code class="language-bash">$ git remote add origin https://github.com/mindplace/test-repo.git</code></pre>

<p>3. Отправьте (сделайте пуш, push) вашей ветки в Github:</p>

<pre><code class="language-bash">$ git push origin master</code></pre>

<p>4. Вернитесь к экрану репозитория на Github, который вы только что оставили, и обновите его. Название «<strong>Quick setup — if you’ve done this kind of thing before</strong>«. Название должно исчезнуть, и вы должны увидеть свои файлы в репозитории.</p>

<div class="attention-red">Важное замечание. При создании репозитория на GitHub лучше не ставить галочку в пункт где спрашивается про создание файлы README.md, иначе могут возникнуть проблемы при отправки локальных файлов в репозиторий.</div>

<h3><span id="Cto_lucse_sdelat_pered_otpravkoj_lokalnyh_fajlov">Что лучше сделать перед отправкой локальных файлов</span></h3>

<p>Перед отправкой локальных файлов в удаленный репозиторий лучше всего проиндексировать все файлы нашего нового проекта.</p>

<p>После команды <code>git init</code> мы можем командой <code>git status</code> увидеть, что не все файлы находятся в индексе.</p>

<p>Чтобы проиндексировать все файлы текущей папки мы вводим команду:</p>

<pre><code class="language-bash">$ git add .</code></pre>

<p>Точка означает текущую папку.</p>

<p>После того как все файлы проиндексированы мы должны закоммитить наши действия, т.е. зафиксировать:</p>

<pre><code class="language-bash">$ git commit -m "Начало проекта"</code></pre>

<p>Я бы посоветовал делать комментарий не на русском как в примере выше, а на английском. Это будет хорошей привычкой. Т.е. вместо «начало проекта» хорошо бы написать «start project».</p>

<p>Далее командой git status мы проверяем, что всё сделали правильно и видим такой экран:</p>

<div>
<figure><img src="images/git-config-commit.jpg" alt="" class="img-fluid"></figure></div>

<p>Перечислю еще несколько полезных команд для работы с Гитом ниже.</p>

<pre><code class="language-bash">$ git log</code></pre>

<p>Показывает историю коммитов.</p>

<pre><code class="language-bash">$ git show a67105fe991a8318asfsdfsd3453sdffsdf</code></pre>

<p>Команда выше показывает через хеш коммита какие изменения были произведены.</p>

<h2><span id="Rabota_s_dvuh_komputerov">Работа с двух компьютеров</span></h2>

<p>Рассмотрим в этом уроке как получить проект из GitHub на локальную машину и как работать с проектом на двух компьютерах, например, из дома и с работы.</p>

<p><strong>Клонирование</strong> — получение всего репозитория. На гитхабе раньше была кнопка <strong><em>Clone or Download</em></strong>. Но затем этот блок изменили и теперь есть кнопка <strong><em>Code</em></strong> при нажатии на которую появляются инструменты клонирования и скачивания.</p>

<div>
<figure><img src="images/git-clone-1.jpg" alt="" class="img-fluid"></figure></div>

<p>Самое популярное решение — клонирование репозитория по протоколу SSH (см. скриншот). Но также можно выбрать HTTPS протокол или просто скачать ZIP-архив.</p>

<p>Раньше при использовании HTTPS и каждой отправке изменения или получении репозитория нужно было вводить пароль от Гитхаба. При использовании SSH мы один раз генерируем ключи на каждом компьютере и добавляем их в Гитхаб.</p>

<p>При этом мы уже знаем, что приватный SSH ключ мы можем защитить паролем, что улучшает безопасность использования данного метода.</p>

<p>Даже если кто-то украдет ваш ключ, вы просто удалите его из Гитхаба в Настройках (<strong>Settings</strong>) и зададите новый.</p>

<p>Но бывает так, что SSH не работает по каким-либо причинам — настройка сети в организации или по другой причине. Тогда у нас остается вариант работы только с HTTPS.</p>

<p>Мы выбираем SSH. Копируем на github адрес и вставляем в терминал:</p>

<pre><code class="language-bash">$ git clone &lt;ssh_key&gt;</code></pre>

<p>Вот так проходит процесс клонирования:</p>

<div>
<figure><img src="images/git-clone-2.jpg" alt="" class="img-fluid"></figure></div>

<p>Теперь посмотрим лог:</p>

<pre><code class="language-bash">$ git log --oneline</code></pre>

<p>Мы увидим все коммиты:</p>
<div>
<figure><img src="images/git-clone-3.jpg" alt="" class="img-fluid"></figure></div>

<p>Также мы видим, что находимся в ветке <strong>master</strong>. Кроме того есть еще два дополнительных указателя — <strong>origin/master</strong> и <strong>origin/HEAD</strong>.</p>

<p>Указатель origin — это имя удаленного репозитория и так принято его называть в мире разработчиков. Мы можем проверить это таким образом:</p>

<pre><code class="language-bash">$ git remote -v</code></pre>

<p>В гитхабе <strong>HEAD</strong> всегда будет указывать на <strong>master</strong>, если вы не измените этого сами в настройках репозитория на самом Гитхабе.</p>

<p>Теперь, если после клонирования мы сделаем новый коммит, то он не появится на Гитхабе, а будет только на локальной машине. Поэтому для отправки изменений в удаленный репозиторий есть команда <strong>push</strong> (рус. толкать или отправить), а для получения <strong>pull</strong> (рус. — тянуть).</p>

<p>Отправляем новые изменения следующей командой:</p>

<pre><code class="language-bash">$ git push origin master</code></pre>

<p>Этот процесс займет немного времени и терминал выведет:</p>

<div>
<figure><img src="images/git-clone-4.jpg" alt="" class="img-fluid"></figure></div>

<p>Если мы создаем ветки и коммиты локально, что они не появляются на Гитхабе автоматически. Если мы создаем ветку <strong>comments</strong>, то команда отправки на Гитхаб всех изменений будет выглядеть так:</p>

<pre><code class="language-bash">$ git push origin comments</code></pre>

<p>И мы увидим отчет в терминале, что изменения отправлены:</p>

<div>
<figure><img src="images/git-clone-5.jpg" alt="" class="img-fluid"></figure></div>

<p>При этом мы теперь на самом GitHub сможем выбрать нужную нам ветку:</p>

<div>
<figure><img src="images/git-clone-6.jpg" alt="" class="img-fluid"></figure></div>

<p>При этом важно понимать, что для разных веток состояние репозитория будет отличаться, если в ветках сделаны разные изменения.</p>

<p>Если мы сделали ошибку в названии ветки, но хотим это исправить, то нам нужно сделать пуш в правильную ветку вот такой командой:</p>

<pre><code class="language-bash">$ git push origin cmments:comments</code></pre>

<p>Таким образом можно отправить любую локальную ветку в удаленную ветку даже если у них разные имена. При этом старая ветка на GitHub останется.</p>

<p>Чтобы удалить старую ветку, которая нам теперь не нужна, мы используем команду:</p>

<pre><code class="language-bash">$ git push origin :cmments</code></pre>

<p>Т.е. мы, условно, пушим «ничего» в старую ветку в удаленный репозиторий. Но теперь на удаленном репозитории старой ветки нет, а локально она есть со старым названием. Нам нужно использовать на локальной машине в терминале такую команду:</p>

<pre><code class="language-bash">$ git branch -m comments</code></pre>

<p>Команда <strong><em>branch</em></strong> может переименовывать, создавать и удалять ветки.</p>

<div class="attention-blue"><strong>Справка</strong>. Команда <code>git checkout -b branch-name</code> создаст ветку с указанным именем и автоматически переключится на неё. Для переключения на существующую ветку выполните команду <code>git checkout</code>. Для переключения, например, на ветку testing используем команду <code>$ git checkout testing</code>. В результате указатель <strong>HEAD</strong> переместится на ветку <strong>testing</strong>.</div>

<p>Чтобы нам наглядно посмотреть ветки в CMDER мы используем команду:</p>

<pre><code class="language-bash">$ git log --oneline --graph --all</code></pre>

<p>Допустим, вы сделали коммиты на рабочем компьютере и теперь хотите поработать дома. Нам нужно получить эти коммиты на домашний компьютер.</p>

<p>Если нам нужно получить изменения ветки <strong>master</strong>, значит нам нужно быть в ветке <strong>master</strong>. Для этого убеждаемся, что мы находимся в ветке master:</p>

<pre><code class="language-bash">$ git status</code></pre>

<p>И далее вводим команду:</p>

<pre><code class="language-bash">$ git pull origin master</code></pre>

<p>Что делать, если кроме ветки <strong>master</strong> нам нужна ветка, которая создана в удаленном репозитории и про которую локальный Git ничего не знает?</p>

<p>Для этого мы используем команду <strong>fetch</strong> (рус.  -получить, принести):</p>

<pre><code class="language-bash">$ git fetch origin</code></pre>

<p>Эта команда позволит забрать изменения из удаленной ветки:</p>

<div>
<figure><img src="images/git-clone-7.jpg" alt="" class="img-fluid"></figure></div>

<p>Схематично это выглядит так:</p>

<div>
<figure><img src="images/git-clone-8.jpg" alt="" class="img-fluid"></figure></div>

<p>Указатели <strong>origin/master</strong> и <strong>origin/comments</strong> (из примера) нельзя удалить или переименовать.</p>

<p>Теперь для примера мы создадим ветку <strong>comments</strong>, которая будет указывать на тот же коммит, что и <strong>origin/comments</strong>:</p>

<pre><code class="language-bash">$ git checkout -b comments origin/comments</code></pre>

<p>Если вы внесли изменения в файлы и сделали новые коммиты на домашнем компьютере, то нам нужно отправить их в GitHub, чтобы иметь возможность работать с новыми изменениями с рабочего компа.</p>

<p>Для ветки <strong>comments</strong> мы можем написать следующую команду:</p>

<pre><code class="language-bash">$ git push origin comments</code></pre>

<p>Но что, если мы хотим всё время пушить <strong>comments</strong> в <strong>comments</strong> на GitHub, а локальный <strong>master</strong> в удаленный <strong>master</strong>? У нас есть возможность связать локальную ветку с удаленной:</p>

<pre><code class="language-bash">$ git branch --set-upstream-to=origin/comments</code></pre>

<p>В примере выше вместо origin/comments вы можете указать имя удаленной ветки с которой вы хотите связать текущую.</p>

<p>Теперь находясь в этой ветке нет необходимости писать названия веток для команды <strong>git push</strong> или <strong>git pull</strong>.</p>

<p>Чтобы посмотреть какие локальные ветки связаны с удаленными мы используем:</p>

<pre><code class="language-bash">$ git branch -vv</code></pre>

<p>Терминал нам покажет какие ветки с какими связаны:</p>
<div>
<figure><img src="images/git-clone-9.jpg" alt="" class="img-fluid"></figure></div>

<p>Видно, что <strong>comments</strong> связана с веткой <strong>origin/comments</strong> и отмечена звездочкой — мы в ней находимся, а <strong>master</strong> связан с <strong>origin/master</strong>.</p>

<p>Теперь мы просто можем писать в терминале:</p>

<pre><code class="language-bash">$ git push</code></pre>

<p>Т.е. мы не вводили имена веток.</p>

<h2><span id="Kod_v_cuzoj_repozitorij_GitHub_ili_pomogaem_drugu">Код в чужой репозиторий GitHub или помогаем другу</span></h2>

<p>Рассмотрим как нам присылать код в чужой репозиторий и как мы можем помогать другим в сервисе контроля версий Git.</p>

<p>Мы не можем просто так клонировать чужой проект, внести изменения и запушить их в чужой репозиторий, т.к. изменения могут попасть в проект только с согласия автора.</p>

<p>Для начала нам нужно «форкнуть» (от слова «форк» — <strong>fork</strong>) проект к себе в Гитхаб. И тогда, в свою копию, можно будет пушить изменения.</p>

<p>Форк — это копия репозитория, которым вы управляете. Форки позволяют вносить изменения в проект, не затрагивая исходный репозиторий. Вы можете получать обновления из исходного репозитория или отправлять изменения в него с помощью <strong>pull requests</strong> (пулл реквесты или, дословно, — запросы на вытягивание).</p>

<p>Открываем в GitHub нужный нам проект, репозиторий. И находим кнопку <strong>Fork</strong>.</p>

<div>
<figure><img src="images/git-fork-1.jpg" alt="" class="img-fluid"></figure></div>

<p>Теперь у нас в Гитхабе есть полная копия данного проекта со всеми коммитами и ветками. Также теперь можно клонировать любой репозиторий, но пуш можно делать будет только в свой проект, а не в проект с которого сделан форк.</p>

<p>Сначала мы клонируем репозиторий командой:</p>

<pre><code class="language-bash">$ git clone git@github.com:sergeiermilov/markdown-doc.git</code></pre>

<p>После чего проверяем, так называемые ремоуты:</p>

<pre><code class="language-bash">$ git remote -v</code></pre>

<p>Получаем примерно такой ответ:</p>

<div>
<figure><img src="images/git-fork-2.jpg" alt="" class="img-fluid"></figure></div>

<p>Теперь мы можем спокойно работать над проектом. После того как мы закончим работу и внесем нужные изменение мы сможем сформировать запрос на вливание или <strong>pull request</strong>.</p>

<p>Сначала мы делаем пуш (пример):</p>

<pre><code class="language-bash">$ git push -u origin share-icons</code></pre>

<p>Флаг <code>-u</code> обозначает <strong>upstream</strong>, устанавливает связь между локальной веткой и удаленной.</p>

<p>Дальше мы переходим в GutHub и видим, что гитхаб видит наш пуш и предлагает сделать <strong>pull request</strong>. Мы жмем зеленую кнопку <strong><em>Compare &amp; Pull Request</em></strong>.</p>

<div>
<figure><img src="images/git-fork-3.jpg" alt="" class="img-fluid"></figure></div>

<p>Дальше мы должны заполнить форму — что было сделано и зачем — заголовок и описание. Ниже в этом же окне мы можем посмотреть разницу между ветками, так называемый diff или дифф (от слова — difference — разница). </p>

<p>Жмем кнопку <strong><em>Create Pull Request</em></strong>:</p>

<div>
<figure><img src="images/git-fork-4.jpg" alt="" class="img-fluid"></figure></div>

<p>Теперь можно сказать, что пулл риквест открыт. Автор изначального репозитория, с которого мы делали форк, сможет посмотреть изменения и принять их или отклонить.</p>

<p>Открытые <strong>pull request</strong> всегда показывают актуальную разницу между ветками.</p>

<p>Важно понимать, что форк на Github не синхронизирован с оригиналом автоматически. Но что если в оригинальном репозитории производились какие-либо изменения?</p>

<p>Нужно к себе добавить ремоуты (от англ. — remote). Мы должны зайти в оригинальный репозиторий и скопировать SSH-адрес.</p>

<p>Теперь мы можем ввести локально такую команду:</p>

<pre><code class="language-bash">$ git remote add &lt;rep_name&gt; &lt;ssh_address&gt;</code></pre>

<p>Где <code>&lt;rep_name&gt;</code> — имя репозитория (вы назначаете сами), а <code>&lt;ssh_address&gt;</code> — скопированный SSH-адрес.</p>

<p>Далее переключаемся в <strong>master</strong>:</p>

<pre><code class="language-bash">$ git checkout master</code></pre>

<p>И забираем изменения:</p>

<pre><code class="language-bash">$ git pull &lt;rep_name&gt; master</code></pre>

<p>Теперь можно это всё отправить в свой Гитхаб:</p>

<pre><code class="language-bash">$ git push origin master</code></pre>

<p>Бывают ситуации, когда появляется конфликт между изменениями pull request  и изменениями в оригинальном репозитории. Это происходит если автор оригинального репозитория внес какие-то изменения в ветку master. Сообщение о конфликте мы увидим на странице пулл риквеста.</p>

<p>Этот кофликт очень похож на конфликт, который мы разбирали в уроке про конфликты при слиянии веток или мёрдже.</p>

<p>Конфликт можно решить у себя. Для этого мы должны влить изменения мастера автора к себе и внести изменения у себя локально. После этого, если мы сделаем push, то конфликт должен исчезнуть и можно будет сделать <strong>pull request</strong>.</p>

<p>Коротко весь процесс выглядит так: Fork -&gt; Внесение изменений -&gt; Pull Request. При этом на Гитхабе можно форкнуть любой публичный репозиторий.</p>

<p>Итак, если есть репозиторий с которым нужно будет работать в компании, то сперва мы должны его скопировать, т.е. сделать форк. Таким образом у нас будет полная копия репозитория и она будет полностью принадлежать нам.</p>

<p>С этим своим репозиторием мы можем теперь спокойно работать и вносить в него изменения. </p>

<p>Далее нам нужно его (форк) клонировать на свою локальную машину.</p>

<p>Схематично во время обучения в HTMLAcademy процесс выглядел так:</p>

<div>
<figure><img src="images/git-fork-5.jpg" alt="" class="img-fluid"></figure></div>

<p>Или так немного нагляднее:</p>

<div>
<figure><img src="images/git-fork-6.jpg" alt="" class="img-fluid"></figure></div>

<p>Т.е. мы сделали форк и дальше клонируем репозиторий на локальный компьютер:</p>

<div>
<figure><img src="images/git-fork-7.jpg" alt="" class="img-fluid"></figure></div>

<p>Далее мы создаем отдельную ветку:</p>

<div>
<figure><img src="images/git-fork-8.jpg" alt="" class="img-fluid"></figure></div>

<p>В этой ветке мы вносим нужные нам изменения, далее индексируем изменения и делаем коммит.</p>

<div>
<figure><img src="images/git-fork-9.jpg" alt="" class="img-fluid"></figure></div>

<p>Дальше, мы делаем пуш, т.е. отправляем изменения на Гитхаб:</p>

<div>
<figure><img src="images/git-fork-10.jpg" alt="" class="img-fluid"></figure></div>

<p> После чего GitHub предложит сделать <strong>pull request</strong>.</p>

<div>
<figure><img src="images/git-fork-11.jpg" alt="" class="img-fluid"></figure></div>

<p>Что делаем дальше, если дается новое задание? Возвращаемся в Git и переключаемся на ветку <strong>master</strong>.</p>

<p>Дальше нужно установить связь (ремоут) не только с личным репозиторием, но и с репозиторием от которого делали форк.</p>

<div>
<figure><img src="images/git-fork-12.jpg" alt="" class="img-fluid"></figure></div>

<p>Как видим на скриншоте — у нас есть ремоут только с личным репозиторием.</p>

<p>Добавим основной репозиторий:</p>

<div>
<figure><img src="images/git-fork-13.jpg" alt="" class="img-fluid"></figure></div>

<p>Эту команду мы уже использовали выше:</p>

<pre><code class="language-bash">$ git remote add &lt;rep_name&gt; &lt;ssh_address&gt;</code></pre>

<p>Как видим, у нас теперь есть дополнительные ремоуты:</p>

<div>
<figure><img src="images/git-fork-14.jpg" alt="" class="img-fluid"></figure></div>

<p>Теперь обновляемся и делаем <strong>pull</strong> изменений:</p>

<div>
<figure><img src="images/git-fork-15.jpg" alt="" class="img-fluid"></figure></div>

<p>Делаем <strong>pull</strong> из основного репозитория. И теперь сможем работать и вносить изменения на локальной машине.</p>


		</div>
	</div>
</div>
<div class="container">
	<div class="row">
		<div class="col-12 col-md-7">
			<div class="mb-3 mb-mb-4 d-flex gap-3">
				<div>
					<img alt="Сергей Ермилов" src="../../../assets/images/sergei-450.png" height="68" width="68">
				</span>
				</div>
				<div>
					<a href="../../about/" class="link-dark link-offset-2 link-underline-opacity-25 link-underline-opacity-100-hover">Сергей Ермилов</a><br>
					<span>Дизайнер, верстальщик, фронтенд-разработчик, PHP и WordPress энтузиаст, главный редактор сайта</span>
				</div>
			</div> 
		</div>
		<div class="col-12 col-md-5">
			<span class="text-muted">Опубликовано 3 января 2023 в 23:56</span><br>Теги: Git
		</div>
	</div>
</div>

<!-- ------------ -->
<!-- START FOOTER -->
<!-- ------------ -->
<footer class="py-5">
	<div class="container">
		<div class="row">
			<div class="col-12 col-md-4 my-auto">
				<span class="fw-500 text-muted">Uzabila</span>
			</div>
			<div class="col-12 col-md-4 text-center my-auto">
				<img src="../../../assets/images/sergei-150.png" alt="Sergei Ermilov" width="80" height="80">
			</div>
			<div class="col-12 col-md-4 my-auto text-end">
				<span class="fw-500 text-muted">&copy; 2008-<script>document.write(new Date().getFullYear())</script></span>
			</div>
		</div>
	</div>
</footer>

	<script src="../../../assets/js/bootstrap.bundle.min.js"></script>
	<script src="../../../assets/js/app.js"></script>
	<script src="../../../assets/js/prism.js"></script>	

  </body>
</html>